{"uploader":"garyb","packageMeta":{"homepage":"https://github.com/purescript/purescript-eff","repository":{"url":"git://github.com/purescript/purescript-eff.git","type":"git"},"ignore":["**/.*","bower_components","node_modules","output","test","bower.json","package.json"],"dependencies":{"purescript-prelude":"^2.1.0"},"name":"purescript-eff","license":["MIT"],"description":"The Eff monad, for handling native side effects"},"modules":[{"reExports":[],"name":"Control.Monad.Eff","comments":null,"declarations":[{"children":[{"comments":null,"title":"functorEff","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Functor"],"Functor"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"e"}]}}]}},"sourceSpan":{"start":[26,1],"name":"src/Control/Monad/Eff.purs","end":[27,15]}},{"comments":null,"title":"applyEff","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Apply"],"Apply"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"e"}]}}]}},"sourceSpan":{"start":[29,1],"name":"src/Control/Monad/Eff.purs","end":[30,13]}},{"comments":null,"title":"applicativeEff","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Applicative"],"Applicative"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"e"}]}}]}},"sourceSpan":{"start":[32,1],"name":"src/Control/Monad/Eff.purs","end":[33,15]}},{"comments":null,"title":"bindEff","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Bind"],"Bind"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"e"}]}}]}},"sourceSpan":{"start":[37,1],"name":"src/Control/Monad/Eff.purs","end":[38,15]}},{"comments":null,"title":"monadEff","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad"],"Monad"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"e"}]}}]}},"sourceSpan":{"start":[42,1],"name":"src/Control/Monad/Eff.purs","end":[42,35]}}],"comments":"The `Eff` type constructor is used to represent _native_ effects.\n\nSee [Handling Native Effects with the Eff Monad](http://www.purescript.org/learn/eff/)\nfor more details.\n\nThe first type parameter is a row of effects which represents the contexts\nin which a computation can be run, and the second type parameter is the\nreturn type.\n","title":"Eff","info":{"kind":{"tag":"FunKind","contents":[{"tag":"Row","contents":{"tag":"Bang","contents":[]}},{"tag":"FunKind","contents":[{"tag":"Star","contents":[]},{"tag":"Star","contents":[]}]}]},"declType":"externData"},"sourceSpan":{"start":[24,1],"name":"src/Control/Monad/Eff.purs","end":[24,41]}},{"children":[],"comments":"The `Pure` type synonym represents _pure_ computations, i.e. ones in which\nall effects have been handled.\n\nThe `runPure` function can be used to run pure computations and obtain\ntheir result.\n","title":"Pure","info":{"arguments":[["a",null]],"declType":"typeSynonym","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"REmpty","contents":[]}]},{"tag":"TypeVar","contents":"a"}]}},"sourceSpan":{"start":[49,1],"name":"src/Control/Monad/Eff.purs","end":[49,23]}},{"children":[],"comments":"Run a pure computation and return its result.\n","title":"runPure","info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Pure"]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeVar","contents":"a"}]},null]}},"sourceSpan":{"start":[52,1],"name":"src/Control/Monad/Eff.purs","end":[52,48]}},{"children":[],"comments":"Loop until a condition becomes `true`.\n\n`untilE b` is an effectful computation which repeatedly runs the effectful\ncomputation `b`, until its return value is `true`.\n","title":"untilE","info":{"declType":"value","type":{"tag":"ForAll","contents":["e",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"e"}]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"e"}]},{"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},null]}},"sourceSpan":{"start":[58,1],"name":"src/Control/Monad/Eff.purs","end":[58,63]}},{"children":[],"comments":"Loop while a condition is `true`.\n\n`whileE b m` is effectful computation which runs the effectful computation\n`b`. If its result is `true`, it runs the effectful computation `m` and\nloops. If not, the computation ends.\n","title":"whileE","info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["e",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"e"}]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"e"}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"e"}]},{"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]}]},null]},null]}},"sourceSpan":{"start":[65,1],"name":"src/Control/Monad/Eff.purs","end":[65,76]}},{"children":[],"comments":"Loop over a consecutive collection of numbers.\n\n`forE lo hi f` runs the computation returned by the function `f` for each\nof the inputs between `lo` (inclusive) and `hi` (exclusive).\n","title":"forE","info":{"declType":"value","type":{"tag":"ForAll","contents":["e",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"e"}]},{"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]}}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"e"}]},{"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]}]}]},null]}},"sourceSpan":{"start":[71,1],"name":"src/Control/Monad/Eff.purs","end":[71,81]}},{"children":[],"comments":"Loop over an array of values.\n\n`foreach xs f` runs the computation returned by the function `f` for each\nof the inputs `xs`.\n","title":"foreachE","info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["e",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"e"}]},{"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]}}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"e"}]},{"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]}]},null]},null]}},"sourceSpan":{"start":[77,1],"name":"src/Control/Monad/Eff.purs","end":[77,78]}}]},{"reExports":[],"name":"Control.Monad.Eff.Class","comments":null,"declarations":[{"children":[{"comments":null,"title":"liftEff","info":{"declType":"typeClassMember","type":{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"eff"}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"a"}]}]},null]}},"sourceSpan":null},{"comments":null,"title":"monadEffEff","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff","Class"],"MonadEff"]},{"tag":"TypeVar","contents":"eff"}]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"eff"}]}}]}},"sourceSpan":{"start":[22,1],"name":"src/Control/Monad/Eff/Class.purs","end":[23,13]}}],"comments":"The `MonadEff` class captures those monads which support native effects.\n\nInstances are provided for `Eff` itself, and the standard monad\ntransformers.\n\n`liftEff` can be used in any appropriate monad transformer stack to lift an\naction of type `Eff eff a` into the monad.\n\nNote that `MonadEff` is parameterized by the row of effects, so type\ninference can be tricky. It is generally recommended to either work with a\npolymorphic row of effects, or a concrete, closed row of effects such as\n`(trace :: Trace)`.\n","title":"MonadEff","info":{"arguments":[["eff",null],["m",null]],"declType":"typeClass","superclasses":[{"constraintClass":[["Control","Monad"],"Monad"],"constraintArgs":[{"tag":"TypeVar","contents":"m"}],"constraintData":null}]},"sourceSpan":{"start":[19,1],"name":"src/Control/Monad/Eff/Class.purs","end":[20,40]}}]},{"reExports":[],"name":"Control.Monad.Eff.Unsafe","comments":null,"declarations":[{"children":[],"comments":"Change the type of an effectful computation, allowing it to be run in\nanother context.\n\n*Note*: use of this function can result in arbitrary side-effects.\n","title":"unsafeCoerceEff","info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["eff2",{"tag":"ForAll","contents":["eff1",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"eff1"}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"eff2"}]},{"tag":"TypeVar","contents":"a"}]}]},null]},null]},null]}},"sourceSpan":{"start":[10,1],"name":"src/Control/Monad/Eff/Unsafe.purs","end":[13,16]}},{"children":[],"comments":"Run an effectful computation.\n\n*Note*: use of this function can result in arbitrary side-effects.\n","title":"unsafePerformEff","info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["eff",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Eff"],"Eff"]},{"tag":"TypeVar","contents":"eff"}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeVar","contents":"a"}]},null]},null]}},"sourceSpan":{"start":[18,1],"name":"src/Control/Monad/Eff/Unsafe.purs","end":[18,49]}}]}],"resolvedDependencies":{"purescript-prelude":"2.1.0"},"bookmarks":[{"package":null,"item":["Control.Monad.Eff","Eff"]},{"package":null,"item":["Control.Monad.Eff","Pure"]},{"package":null,"item":["Control.Monad.Eff","runPure"]},{"package":null,"item":["Control.Monad.Eff","untilE"]},{"package":null,"item":["Control.Monad.Eff","whileE"]},{"package":null,"item":["Control.Monad.Eff","forE"]},{"package":null,"item":["Control.Monad.Eff","foreachE"]},{"package":null,"item":["Control.Monad.Eff.Class","MonadEff"]},{"package":null,"item":["Control.Monad.Eff.Class","monadEffEff"]},{"package":null,"item":["Control.Monad.Eff.Unsafe","unsafeCoerceEff"]},{"package":null,"item":["Control.Monad.Eff.Unsafe","unsafePerformEff"]},{"package":"purescript-prelude","item":["Control.Category","Category"]},{"package":"purescript-prelude","item":["Control.Category","categoryFn"]},{"package":"purescript-prelude","item":["Control.Bind","Bind"]},{"package":"purescript-prelude","item":["Control.Bind","(>>=)"]},{"package":"purescript-prelude","item":["Control.Bind","bindFlipped"]},{"package":"purescript-prelude","item":["Control.Bind","(=<<)"]},{"package":"purescript-prelude","item":["Control.Bind","bindFn"]},{"package":"purescript-prelude","item":["Control.Bind","join"]},{"package":"purescript-prelude","item":["Control.Bind","composeKleisli"]},{"package":"purescript-prelude","item":["Control.Bind","(>=>)"]},{"package":"purescript-prelude","item":["Control.Bind","composeKleisliFlipped"]},{"package":"purescript-prelude","item":["Control.Bind","(<=<)"]},{"package":"purescript-prelude","item":["Control.Bind","ifM"]},{"package":"purescript-prelude","item":["Control.Semigroupoid","Semigroupoid"]},{"package":"purescript-prelude","item":["Control.Semigroupoid","semigroupoidFn"]},{"package":"purescript-prelude","item":["Control.Semigroupoid","(<<<)"]},{"package":"purescript-prelude","item":["Control.Semigroupoid","composeFlipped"]},{"package":"purescript-prelude","item":["Control.Semigroupoid","(>>>)"]},{"package":"purescript-prelude","item":["Control.Applicative","Applicative"]},{"package":"purescript-prelude","item":["Control.Applicative","applicativeFn"]},{"package":"purescript-prelude","item":["Control.Applicative","liftA1"]},{"package":"purescript-prelude","item":["Control.Applicative","when"]},{"package":"purescript-prelude","item":["Control.Applicative","when"]},{"package":"purescript-prelude","item":["Control.Applicative","unless"]},{"package":"purescript-prelude","item":["Control.Applicative","unless"]},{"package":"purescript-prelude","item":["Control.Monad","Monad"]},{"package":"purescript-prelude","item":["Control.Monad","monadFn"]},{"package":"purescript-prelude","item":["Control.Monad","liftM1"]},{"package":"purescript-prelude","item":["Control.Monad","ap"]},{"package":"purescript-prelude","item":["Control.Monad","whenM"]},{"package":"purescript-prelude","item":["Control.Monad","unlessM"]},{"package":"purescript-prelude","item":["Control.Apply","Apply"]},{"package":"purescript-prelude","item":["Control.Apply","(<*>)"]},{"package":"purescript-prelude","item":["Control.Apply","applyFn"]},{"package":"purescript-prelude","item":["Control.Apply","applyFirst"]},{"package":"purescript-prelude","item":["Control.Apply","(<*)"]},{"package":"purescript-prelude","item":["Control.Apply","applySecond"]},{"package":"purescript-prelude","item":["Control.Apply","(*>)"]},{"package":"purescript-prelude","item":["Control.Apply","lift2"]},{"package":"purescript-prelude","item":["Control.Apply","lift3"]},{"package":"purescript-prelude","item":["Control.Apply","lift4"]},{"package":"purescript-prelude","item":["Control.Apply","lift5"]},{"package":"purescript-prelude","item":["Data.Unit","Unit"]},{"package":"purescript-prelude","item":["Data.Unit","unit"]},{"package":"purescript-prelude","item":["Data.Unit","showUnit"]},{"package":"purescript-prelude","item":["Data.Field","Field"]},{"package":"purescript-prelude","item":["Data.Ord","Ord"]},{"package":"purescript-prelude","item":["Data.Ord","lessThan"]},{"package":"purescript-prelude","item":["Data.Ord","greaterThan"]},{"package":"purescript-prelude","item":["Data.Ord","lessThanOrEq"]},{"package":"purescript-prelude","item":["Data.Ord","greaterThanOrEq"]},{"package":"purescript-prelude","item":["Data.Ord","(<)"]},{"package":"purescript-prelude","item":["Data.Ord","(<=)"]},{"package":"purescript-prelude","item":["Data.Ord","(>)"]},{"package":"purescript-prelude","item":["Data.Ord","(>=)"]},{"package":"purescript-prelude","item":["Data.Ord","comparing"]},{"package":"purescript-prelude","item":["Data.Ord","min"]},{"package":"purescript-prelude","item":["Data.Ord","max"]},{"package":"purescript-prelude","item":["Data.Ord","clamp"]},{"package":"purescript-prelude","item":["Data.Ord","between"]},{"package":"purescript-prelude","item":["Data.Ord","abs"]},{"package":"purescript-prelude","item":["Data.Ord","signum"]},{"package":"purescript-prelude","item":["Data.BooleanAlgebra","BooleanAlgebra"]},{"package":"purescript-prelude","item":["Data.Function","flip"]},{"package":"purescript-prelude","item":["Data.Function","const"]},{"package":"purescript-prelude","item":["Data.Function","apply"]},{"package":"purescript-prelude","item":["Data.Function","($)"]},{"package":"purescript-prelude","item":["Data.Function","applyFlipped"]},{"package":"purescript-prelude","item":["Data.Function","(#)"]},{"package":"purescript-prelude","item":["Data.Function","on"]},{"package":"purescript-prelude","item":["Data.Void","Void"]},{"package":"purescript-prelude","item":["Data.Void","absurd"]},{"package":"purescript-prelude","item":["Data.CommutativeRing","CommutativeRing"]},{"package":"purescript-prelude","item":["Data.Show","Show"]},{"package":"purescript-prelude","item":["Data.Semiring","Semiring"]},{"package":"purescript-prelude","item":["Data.Semiring","(+)"]},{"package":"purescript-prelude","item":["Data.Semiring","(*)"]},{"package":"purescript-prelude","item":["Data.HeytingAlgebra","HeytingAlgebra"]},{"package":"purescript-prelude","item":["Data.HeytingAlgebra","(&&)"]},{"package":"purescript-prelude","item":["Data.HeytingAlgebra","(||)"]},{"package":"purescript-prelude","item":["Data.HeytingAlgebra","heytingAlgebraFunction"]},{"package":"purescript-prelude","item":["Data.Ring","Ring"]},{"package":"purescript-prelude","item":["Data.Ring","(-)"]},{"package":"purescript-prelude","item":["Data.Ring","negate"]},{"package":"purescript-prelude","item":["Data.Eq","Eq"]},{"package":"purescript-prelude","item":["Data.Eq","(==)"]},{"package":"purescript-prelude","item":["Data.Eq","notEq"]},{"package":"purescript-prelude","item":["Data.Eq","(/=)"]},{"package":"purescript-prelude","item":["Data.Ordering","Ordering"]},{"package":"purescript-prelude","item":["Data.Ordering","invert"]},{"package":"purescript-prelude","item":["Data.Ordering","invert"]},{"package":"purescript-prelude","item":["Data.Ordering","invert"]},{"package":"purescript-prelude","item":["Data.Functor","Functor"]},{"package":"purescript-prelude","item":["Data.Functor","(<$>)"]},{"package":"purescript-prelude","item":["Data.Functor","mapFlipped"]},{"package":"purescript-prelude","item":["Data.Functor","(<#>)"]},{"package":"purescript-prelude","item":["Data.Functor","functorFn"]},{"package":"purescript-prelude","item":["Data.Functor","void"]},{"package":"purescript-prelude","item":["Data.Functor","voidRight"]},{"package":"purescript-prelude","item":["Data.Functor","(<$)"]},{"package":"purescript-prelude","item":["Data.Functor","voidLeft"]},{"package":"purescript-prelude","item":["Data.Functor","($>)"]},{"package":"purescript-prelude","item":["Data.Functor","flap"]},{"package":"purescript-prelude","item":["Data.Functor","(<@>)"]},{"package":"purescript-prelude","item":["Data.Boolean","otherwise"]},{"package":"purescript-prelude","item":["Data.EuclideanRing","EuclideanRing"]},{"package":"purescript-prelude","item":["Data.EuclideanRing","(/)"]},{"package":"purescript-prelude","item":["Data.Semigroup","Semigroup"]},{"package":"purescript-prelude","item":["Data.Semigroup","(<>)"]},{"package":"purescript-prelude","item":["Data.Semigroup","semigroupFn"]},{"package":"purescript-prelude","item":["Data.NaturalTransformation","NaturalTransformation"]},{"package":"purescript-prelude","item":["Data.NaturalTransformation","type (~>)"]},{"package":"purescript-prelude","item":["Data.Bounded","Bounded"]},{"package":"purescript-prelude","item":["Data.Ord.Unsafe","unsafeCompare"]}],"version":"2.0.0","github":["purescript","purescript-eff"],"versionTag":"v2.0.0","compilerVersion":"0.9.1"}