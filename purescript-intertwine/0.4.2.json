{"uploader":"fsoikin","packageMeta":{"repository":{"url":"https://github.com/collegevine/purescript-intertwine.git","type":"git"},"ignore":["**/.*","node_modules","bower_components","output"],"devDependencies":{"purescript-spec":"^3.1.0","purescript-psci-support":"^4.0.0","purescript-spec-quickcheck":"^3.1.0","purescript-quickcheck":"^5.0.0"},"authors":[{"email":"fyodor@collegevine.com","name":"Fyodor Soikin"},{"name":"CollegeVine"}],"dependencies":{"purescript-unicode":"^4.0.1","purescript-maybe":"^4.0.0","purescript-profunctor-lenses":"^4.0.0","purescript-foreign-object":"^1.0.0","purescript-prelude":"^4.1.0","purescript-generics-rep":"^6.1.0","purescript-strings":"^4.0.1","purescript-foreign":"^5.0.0"},"name":"purescript-intertwine","license":["MIT"],"description":"Reversible printing/parsing"},"tagTime":"2019-05-22T23:04:42+0000","modules":[{"reExports":[{"moduleName":{"package":null,"item":["Data","Intertwine","Syntax"]},"declarations":[{"children":[{"comments":null,"title":"printerSyntax","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Syntax"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Printer"]}]}},"sourceSpan":{"start":[206,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[206,41]}}],"comments":"An implementation of `Syntax` for printing.\n","title":"Printer","info":{"declType":"data","dataDeclType":"newtype","typeArguments":[["state",null],["a",null]]},"sourceSpan":{"start":[204,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[204,65]}},{"children":[{"comments":null,"title":"parserSyntax","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Syntax"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Parser"]}]}},"sourceSpan":{"start":[237,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[237,39]}}],"comments":"An implementation of `Syntax` for parsing.\n","title":"Parser","info":{"declType":"data","dataDeclType":"newtype","typeArguments":[["state",null],["a",null]]},"sourceSpan":{"start":[235,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[235,65]}},{"children":[{"comments":null,"title":"Ctor","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null}],"comments":"This type is equivalent to `SProxy`, but provided here separately for the\npurpose of shortening the code in combination with the `<|:|>` operator\n(see comments there).\n","title":"Ctor","info":{"declType":"data","dataDeclType":"data","typeArguments":[["name",{"annotation":[],"tag":"NamedKind","contents":[["Prim"],"Symbol"]}]]},"sourceSpan":{"start":[179,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[179,34]}},{"children":[{"comments":null,"title":"atom","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[119,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[119,85]}},{"comments":null,"title":"synApply","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[120,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[120,95]}},{"comments":null,"title":"synInject","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[121,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[121,79]}},{"comments":null,"title":"alt","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]}},"sourceSpan":{"start":[122,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[122,78]}},{"comments":null,"title":"printerSyntax","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Syntax"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Printer"]}]}},"sourceSpan":{"start":[206,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[206,41]}},{"comments":null,"title":"parserSyntax","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Syntax"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Parser"]}]}},"sourceSpan":{"start":[237,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[237,39]}}],"comments":"An implementation of reversible printer-parser.\n\nThe goal is to provide the means for expressing representation of data\nstructures in a way that allows the same representation to be used for both\nparsing and printing, thus eliminating the need for code duplication and\nensuring that the printer and the parser don't diverge.\n\nThe type variable `syntax` here represents either a printer or a parser\n(see instances below). This printer-or-parser type, in turn, takes two\ngeneric parameters: parsing/printing state and the value being\nparsed/printed.\n\nThe thought process goes like this: first, we realize that all data is\nrepresentable as sum types, so we limit ourselves to working with sum\ntypes, or at least with something functionally equivalent.\n\nNext, since our syntax has to convert the value both ways, it follows that\nwe need, for every constructor of the sum type, a way to convert from its\nparameters to the type and back again. This concept is represented by the\npartial isomorphisms defined in ./Iso.purs (partial, because the conversion\nis not always possible). These isomorphisms are then automatically\ngenerated for each constructor via `Generic` - this generation code is in\n./MkIso.purs\n\nOnce we have an isomorphism for a constructor, it is tempting to follow the\nfamiliar parser structure:\n\n     data Foo = Foo Int String\n     parseFoo = Foo <$> parseInt <*> parseString\n\nHowever, the usual Functor style won't work here, because our syntax needs\nnot only to produce values (which is what Functors handle), but also to\n_consume_ them.\n\nIn order to do that, we work the other way around - instead of gradually\naccumulating the partially applied function within the functor from left to\nright, we work from from right to left, first accumulating all the\nparsers/printers that need to be \"applied\" to the constructor, and only\nthen injecting the constructor itself.\n\nThus:\n\n    pa :: Printer a\n    pb :: Printer b\n    pa `synApply` pb :: Printer (a, b)\n\nCombining the two printers gives us a printer that can print a tuple (same\nfor parsers). After that, such printer can be applied to the\nconstructor-derived Iso:\n\n    p :: Printer (a, b)\n    i :: Iso (a, b) T\n    i `synInject` p :: Printer T\n\nTo accomodate this, we generate the Iso instances for every constructor in\nsuch a way that converts the constructor's parameters into tuples, e.g.:\n\n    data T = A Int String | B Int String Boolean\n    iso \"A\"  :: Iso (Int, String) T\n    iso \"B\"  :: Iso (Int, (String, Boolean)) T\n\nThis structure nicely matches the structure that results from repeatedly\n`synApply`ing printers/parsers, provided both `synApply` and `synInject`\nare right-associative:\n\n    pInt :: Printer Int\n    pString :: Printer String\n    pBoolean :: Printer Boolean\n    (iso \"B\") `synInject` pInt `synApply` pString `synApply` pBoolean\n\nThe `alt` operation allows to combine multiple printers/parsers and try\nthem out in order - very similar to the (<|>) operator from `Control.Alt`.\n\nFinally, the `atom` operation can be used for creating primitive parsers by\nproviding an `Iso (state, a) (state, ())`. The meaning of such `Iso` is the\nfollowing. The signature of a printing function is `state -> a -> Maybe\nstate`, taken to mean that a printing function takes the state accumulated\nso far (e.g. a string that has been printed so far), then takes a value to\nbe printed, and returns new state. The `Maybe` indicates that printing may\nfail. Conversely, the signature of a parsing function is `state -> Maybe\n(a, state)`, taken to mean that the function takes the state (e.g. the tail\nof the input string that hasn't yet been consumed) and returns both the\nparsed value and the new state (e.g. the new string tail, after consuming\nwhatever was needed to parse the value). To recap:\n\n      print :: state -> a -> Maybe state\n      parse :: state -> Maybe (a, state)\n\nApplying isomorphic manipulations to the signature - specifically,\nuncurrying the arguments, commuting tuples, and noting that `x` is\nisomorphic to `(x,())` - we can get:\n\n      print :: (state, a) -> Maybe (state, ())\n      parse :: (state, ()) -> Maybe (state, a)\n\nWhich is equivalent to `Iso (state, a) (state, ())`. Thus, we can treat an\n`Iso` as a pair of print+parse functions, and thus we can use it to\nconstruct a primitive parser/printer.\n","title":"Syntax","info":{"fundeps":[],"arguments":[["syntax",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[118,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[122,78]}},{"children":[],"comments":"Runs a reversible syntax definition for printing, given an initial printer\nstate.\n\nThe first parameter is supposed to be a polymorphic reversible definition\nsuch as:\n\n    s :: forall syntax. Syntax syntax => syntax a b\n\nPassing such parameter to this function would instantiate the `syntax` type\nvariable to `Printer`, and the printing will commence.\n","title":"print","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Printer"]},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"state"}]}]}]}]},null]},null]}},"sourceSpan":{"start":[226,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[226,70]}},{"children":[],"comments":"Runs a reversible syntax definition for parsing, given an initial parser\nstate.\n\nThe first parameter is supposed to be a polymorphic reversible definition\nsuch as:\n\n    s :: forall syntax. Syntax syntax => syntax a b\n\nPassing such parameter to this function would instantiate the `syntax` type\nvariable to `Parser`, and the parsing will commence.\n","title":"parse","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Parser"]},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"state"}]}}]}]}]},null]},null]}},"sourceSpan":{"start":[259,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[259,74]}},{"children":[],"comments":"Meant to be used as infix operator `<|:|>`, see comments on it.\n","title":"injectConstructor","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["route",{"annotation":[],"tag":"ForAll","contents":["syntax",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["args",{"annotation":[],"tag":"ForAll","contents":["name",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","MkIso"],"MkIso"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"},{"annotation":[],"tag":"TypeVar","contents":"name"},{"annotation":[],"tag":"TypeVar","contents":"args"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Syntax"],"Syntax"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"syntax"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Ctor"]},{"annotation":[],"tag":"TypeVar","contents":"name"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"TypeVar","contents":"args"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]}]},null]},null]},null]},null]},null]}},"sourceSpan":{"start":[195,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[195,141]}},{"children":[],"comments":"Combines two printers/parsers similarly to `synApply`, but ignoring the\nright printer/parser, provided it returns/consumes a unit.\n","title":"dropUnitRight","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"ForAll","contents":["syntax",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Syntax"],"Syntax"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"syntax"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[171,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[171,111]}},{"children":[],"comments":"Combines two printers/parsers similarly to `synApply`, but ignoring the\nleft printer/parser, provided it returns/consumes a unit.\n","title":"dropUnitLeft","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"ForAll","contents":["syntax",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Syntax"],"Syntax"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"syntax"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[156,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[156,110]}},{"children":[],"comments":"Combines two printers/parsers of the same type in a way that first attempts\nthe left one, and if it fails, falls back to the right.\n","title":"(<|||>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"alt"}}}],"fixity":{"associativity":"infixl","precedence":2}},"sourceSpan":{"start":[143,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[143,22]}},{"children":[],"comments":"Binds a constructor, whose name is encoded in the `Ctor` value, to the\ngiven parser/printer.\n\nFor example:\n\n    data T = A String | B (Maybe Int)\n\n    syntax =\n             (Ctor::Ctor \"A\") <|:|> value\n       <|||> (Ctor::Ctor \"B\") <|:|> query \"id\"\n\n","title":"(<|:|>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"injectConstructor"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[192,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[192,36]}},{"children":[],"comments":"Combines two printers/parsers together, iyelding a printer/parser that can\nprint/parse a tuple of the two combined values.\n\n    a :: syntax a\n    b :: syntax b\n    a <|*|> b :: syntax (a, b)\n","title":"(<|*|>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"synApply"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[131,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[131,27]}},{"children":[],"comments":"Combines a printer/parser that consumes/returns a unit with another\nprinter/parser in a way that the unit is dropped instead of becoming part\nof a tuple, as it would with `<|*|>`\n\n    u :: syntax Unit\n    a :: syntax a\n    a <|* u :: syntax a\n","title":"(<|*)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"dropUnitRight"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[167,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[167,30]}},{"children":[],"comments":"Injects an `Iso` into a printer/parser on the right side, producing a\nprinter/parser of the type that is left type of the `Iso`.\n\n    i :: Iso a (b, (c, d))\n    p :: syntax (b, (c, d))\n    i <|$|> p :: syntax a\n","title":"(<|$|>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"synInject"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[139,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[139,28]}},{"children":[],"comments":"Combines a printer/parser that consumes/returns a unit with another\nprinter/parser in a way that the unit is dropped instead of becoming part\nof a tuple, as it would with `<|*|>`\n\n    u :: syntax Unit\n    a :: syntax a\n    u *|> a :: syntax a\n","title":"(*|>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"dropUnitLeft"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[152,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[152,29]}}]}],"name":"Data.Intertwine","comments":null,"declarations":[]},{"reExports":[],"name":"Data.Intertwine.Combinators","comments":"Primitive combinators for Iso\n","declarations":[{"children":[],"comments":"Revereses the direction of an `Iso`\n","title":"isoFlip","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[24,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Combinators.purs","end":[24,42]}},{"children":[],"comments":"Given a `Traversable` and an `Iso` that maps some values `a` and\n`b`, produces a new `Iso` that maps those values wrapped in the\n`Traversable` - `f a` and `f b`. This is handy for working for `Maybe`, for\nexample:\n\n    -- First, define a never-failing Iso that maps a number\n    -- to a number 5 greater than it\n    plus5 :: Iso Int Int\n    plus5 = isoFrom (_ + 5) (_ - 5)\n\n    > plus5.apply 37 == Just 42\n    > plus5.inverse 42 == Just 37\n\n    -- Now, wrap it in a `Maybe`\n    mPlus5 :: Iso (Maybe Int) (Maybe Int)\n    mPlus5 = isoTraverse plus5\n\n    > mPlus5.apply (Just 37) == Just (Just 42)\n    > mPlus5.inverse (Just 42) == Just (Just 37)\n    > mPlus5.apply Nothing == Just Nothing\n    > mPlus5.inverse Nothing == Just Nothing\n\n    -- Or wrap it in an `Array`\n    aPlus5 :: Iso (Array Int) (Array Int)\n    aPlus5 = isoTraverse plus5\n\n    > aPlus5.apply [37, 0] == Just [42, 5]\n    > aPlus5.inverse [42, 5] == Just [37, 0]\n    > aPlus5.apply [] == Just []\n    > aPlus5.inverse [] == Just []\n\n","title":"isoTraverse","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["f",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Traversable"],"Traversable"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"f"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"f"},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[58,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Combinators.purs","end":[58,73]}},{"children":[],"comments":"Constructs a never-failing `Iso` out of given \"apply\" and\n\"inverse\" functions\n","title":"isoFrom","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]},null]},null]}},"sourceSpan":{"start":[20,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Combinators.purs","end":[20,55]}},{"children":[],"comments":"Constructs a never-failing `Iso` mapping a `newtype` to the type\nit wraps. The intended use is to provide the `newtype`'s constructor as\nfirst argument for the purpose of type inference.\n\nExample:\n\n    newtype N = N Int\n    derive instance newtypeN :: Newtype N _\n\n    isoN :: Iso Int N\n    isoN = isoWrap N\n\n    > isoN.apply 42 == Just (N 42)\n    > isoN.inverse (N 42) == Just 42\n\n","title":"isoWrap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["w",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Newtype"],"Newtype"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"w"},{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"w"}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"w"}]}]}]},null]},null]}},"sourceSpan":{"start":[76,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Combinators.purs","end":[76,58]}},{"children":[],"comments":"The opposite of `isoWrap`: constructs a never-failing `Iso` that\nmaps a value to a `newtype` that wraps it. The intended use is to provide\nthe `newtype`'s constructor as first argument for the purpose of type\ninference.\n\nExample:\n\n    newtype N = N Int\n    derive instance newtypeN :: Newtype N _\n\n    isoN :: Iso N Int\n    isoN = isoUnwrap N\n\n    > isoN.apply (N 42) == Just 42\n    > isoN.inverse 42 == Just (N 42)\n\n","title":"isoUnwrap","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["w",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Newtype"],"Newtype"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"w"},{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"w"}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]},{"annotation":[],"tag":"TypeVar","contents":"w"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]}},"sourceSpan":{"start":[95,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Combinators.purs","end":[95,60]}},{"children":[],"comments":"An `Iso` that wraps any value in a `Just`, and unwraps on\ninverse, failing when given `Nothing`.\n\nExample:\n\n    > isoJust.apply 42 == Just (Just 42)\n    > isoJust.inverse (Just 42) = Just 42\n    > isoJust.inverse Nothing = Nothing\n\n","title":"isoJust","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},null]}},"sourceSpan":{"start":[107,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Combinators.purs","end":[107,37]}}]},{"reExports":[],"name":"Data.Intertwine.Iso","comments":null,"declarations":[{"children":[{"comments":null,"title":"Iso","info":{"arguments":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Record"]},{"annotation":[],"tag":"RCons","contents":["apply",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"RCons","contents":["inverse",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"b"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"REmpty"}]}]}]}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"cIso","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Category"],"Category"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]}]}},"sourceSpan":{"start":[16,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Iso.purs","end":[16,30]}},{"comments":null,"title":"smgIso","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Control","Semigroupoid"],"Semigroupoid"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]}]}},"sourceSpan":{"start":[19,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Iso.purs","end":[19,36]}}],"comments":"Partial isomorphism - a pair of functions that can convert between two\ntypes, with a possibility of failure.\n","title":"Iso","info":{"declType":"data","dataDeclType":"data","typeArguments":[["a",null],["b",null]]},"sourceSpan":{"start":[10,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Iso.purs","end":[13,2]}}]},{"reExports":[],"name":"Data.Intertwine.MkIso","comments":null,"declarations":[{"children":[{"comments":null,"title":"iso","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Symbol"],"SProxy"]},{"annotation":[],"tag":"TypeVar","contents":"ctor"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]},{"annotation":[],"tag":"TypeVar","contents":"tuple"}]},{"annotation":[],"tag":"TypeVar","contents":"t"}]}]}},"sourceSpan":{"start":[57,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\MkIso.purs","end":[57,38]}},{"comments":null,"title":"mkIsoCtor","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","MkIso"],"ArgsAsTuple"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"args"},{"annotation":[],"tag":"TypeVar","contents":"argsAsTuple"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","MkIso"],"MkIso"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"Constructor"]},{"annotation":[],"tag":"TypeVar","contents":"name"}]},{"annotation":[],"tag":"TypeVar","contents":"args"}]}]},{"annotation":[],"tag":"TypeVar","contents":"name"}]},{"annotation":[],"tag":"TypeVar","contents":"argsAsTuple"}]}},"sourceSpan":{"start":[60,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\MkIso.purs","end":[60,101]}},{"comments":null,"title":"mkIsoSumLeft","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","MkIso"],"ArgsAsTuple"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"args"},{"annotation":[],"tag":"TypeVar","contents":"argsAsTuple"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","MkIso"],"MkIso"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"Sum"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"Constructor"]},{"annotation":[],"tag":"TypeVar","contents":"ctor"}]},{"annotation":[],"tag":"TypeVar","contents":"args"}]}]},{"annotation":[],"tag":"TypeVar","contents":"rest"}]}]},{"annotation":[],"tag":"TypeVar","contents":"ctor"}]},{"annotation":[],"tag":"TypeVar","contents":"argsAsTuple"}]}},"sourceSpan":{"start":[67,6],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\MkIso.purs","end":[67,120]}},{"comments":null,"title":"mkIsoSumRight","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","MkIso"],"MkIso"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"rest"},{"annotation":[],"tag":"TypeVar","contents":"ctor"},{"annotation":[],"tag":"TypeVar","contents":"tuple"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","MkIso"],"MkIso"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"Sum"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"Constructor"]},{"annotation":[],"tag":"TypeVar","contents":"anotherName"}]},{"annotation":[],"tag":"TypeVar","contents":"y"}]}]},{"annotation":[],"tag":"TypeVar","contents":"rest"}]}]},{"annotation":[],"tag":"TypeVar","contents":"ctor"}]},{"annotation":[],"tag":"TypeVar","contents":"tuple"}]}},"sourceSpan":{"start":[79,6],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\MkIso.purs","end":[79,112]}},{"comments":null,"title":"mkIso","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Generic","Rep"],"Generic"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"t"},{"annotation":[],"tag":"TypeVar","contents":"rep"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Intertwine","MkIso"],"MkIso"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"rep"},{"annotation":[],"tag":"TypeVar","contents":"ctor"},{"annotation":[],"tag":"TypeVar","contents":"tuple"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","MkIso"],"MkIso"]},{"annotation":[],"tag":"TypeVar","contents":"t"}]},{"annotation":[],"tag":"TypeVar","contents":"ctor"}]},{"annotation":[],"tag":"TypeVar","contents":"tuple"}]}},"sourceSpan":{"start":[92,6],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\MkIso.purs","end":[92,83]}}],"comments":"This type class provides the function `iso`, which operates on a sum type.\nIt takes the name of a constructor of that type and returns an `Iso`\ninstance that converts between the sum type itself and the chosen\nconstructor's parameters that are all tupled together, starting with the\nright ones.\n\nFor example:\n\n    data T = A | B String | C Int Number | D Boolean Int String\n\n    iso (SProxy :: SProxy \"A\") :: Iso Unit T\n    iso (SProxy :: SProxy \"B\") :: Iso String T\n    iso (SProxy :: SProxy \"C\") :: Iso (Tuple Int Number) T\n    iso (SProxy :: SProxy \"D\") :: Iso (Tuple Boolean (Tuple Int String)) T\n\nSuch tupling is necessary for the implementation of both printers and\nparsers from the same code structure. See\n[`Syntax`](https://pursuit.purescript.org/packages/purescript-intertwine/docs/Data.Intertwine.Syntax)\nfor a more detailed explanation.\n\nThe resulting `Iso` can always convert \"forward\" (i.e. from\ntupled arguments to `T`), but it can only convert \"backward\" (i.e. from T\nto the corresponding tuple) when the given `T` value was constructed with\nthe given constructor, returning `Nothing` for all other constructors.\n","title":"MkIso","info":{"fundeps":[[["t","ctor"],["tuple"]]],"arguments":[["t",null],["ctor",null],["tuple",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[56,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\MkIso.purs","end":[57,38]}},{"children":[{"comments":null,"title":"argsToTuple","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"args"}]},{"annotation":[],"tag":"TypeVar","contents":"tuple"}]}},"sourceSpan":{"start":[109,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\MkIso.purs","end":[109,33]}},{"comments":null,"title":"tupleToArgs","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"tuple"}]},{"annotation":[],"tag":"TypeVar","contents":"args"}]}},"sourceSpan":{"start":[110,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\MkIso.purs","end":[110,33]}},{"comments":null,"title":"a2tEmpty","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","MkIso"],"ArgsAsTuple"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"NoArguments"]}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}},"sourceSpan":{"start":[112,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\MkIso.purs","end":[112,50]}},{"comments":null,"title":"a2tSingle","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","MkIso"],"ArgsAsTuple"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"Argument"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}},"sourceSpan":{"start":[116,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\MkIso.purs","end":[116,49]}},{"comments":null,"title":"a2tRecursive","info":{"declType":"instance","dependencies":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","MkIso"],"ArgsAsTuple"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"},{"annotation":[],"tag":"TypeVar","contents":"ax"}],"constraintData":null},{"constraintAnn":[],"constraintClass":[["Data","Intertwine","MkIso"],"ArgsAsTuple"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"b"},{"annotation":[],"tag":"TypeVar","contents":"bx"}],"constraintData":null}],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","MkIso"],"ArgsAsTuple"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Generic","Rep"],"Product"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"ax"}]},{"annotation":[],"tag":"TypeVar","contents":"bx"}]}]}},"sourceSpan":{"start":[120,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\MkIso.purs","end":[120,105]}}],"comments":"This type class takes the Generic-rep representation of sum type arguments\nand converts them into a series of nested tuples.\n","title":"ArgsAsTuple","info":{"fundeps":[[["args"],["tuple"]]],"arguments":[["args",null],["tuple",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[108,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\MkIso.purs","end":[110,33]}}]},{"reExports":[{"moduleName":{"package":null,"item":["Data","Intertwine","Route","PathPiece"]},"declarations":[{"children":[{"comments":null,"title":"toPathSegment","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}},"sourceSpan":{"start":[15,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route\\PathPiece.purs","end":[15,33]}},{"comments":null,"title":"fromPathSegment","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[16,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route\\PathPiece.purs","end":[16,41]}},{"comments":null,"title":"pathPieceString","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route","PathPiece"],"PathPiece"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}},"sourceSpan":{"start":[18,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route\\PathPiece.purs","end":[18,45]}},{"comments":null,"title":"pathPieceInt","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route","PathPiece"],"PathPiece"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[22,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route\\PathPiece.purs","end":[22,39]}}],"comments":"This class makes a type suitable for participating in route\nprinting/parsing - i.e. to be the type of path segments and querystring\nparameters.\n","title":"PathPiece","info":{"fundeps":[],"arguments":[["a",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[14,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route\\PathPiece.purs","end":[16,41]}}]},{"moduleName":{"package":null,"item":["Data","Intertwine","Syntax"]},"declarations":[{"children":[{"comments":null,"title":"Ctor","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null}],"comments":"This type is equivalent to `SProxy`, but provided here separately for the\npurpose of shortening the code in combination with the `<|:|>` operator\n(see comments there).\n","title":"Ctor","info":{"declType":"data","dataDeclType":"data","typeArguments":[["name",{"annotation":[],"tag":"NamedKind","contents":[["Prim"],"Symbol"]}]]},"sourceSpan":{"start":[179,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[179,34]}},{"children":[],"comments":"Combines two printers/parsers of the same type in a way that first attempts\nthe left one, and if it fails, falls back to the right.\n","title":"(<|||>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"alt"}}}],"fixity":{"associativity":"infixl","precedence":2}},"sourceSpan":{"start":[143,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[143,22]}},{"children":[],"comments":"Binds a constructor, whose name is encoded in the `Ctor` value, to the\ngiven parser/printer.\n\nFor example:\n\n    data T = A String | B (Maybe Int)\n\n    syntax =\n             (Ctor::Ctor \"A\") <|:|> value\n       <|||> (Ctor::Ctor \"B\") <|:|> query \"id\"\n\n","title":"(<|:|>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"injectConstructor"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[192,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[192,36]}},{"children":[],"comments":"Combines two printers/parsers together, iyelding a printer/parser that can\nprint/parse a tuple of the two combined values.\n\n    a :: syntax a\n    b :: syntax b\n    a <|*|> b :: syntax (a, b)\n","title":"(<|*|>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"synApply"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[131,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[131,27]}},{"children":[],"comments":"Injects an `Iso` into a printer/parser on the right side, producing a\nprinter/parser of the type that is left type of the `Iso`.\n\n    i :: Iso a (b, (c, d))\n    p :: syntax (b, (c, d))\n    i <|$|> p :: syntax a\n","title":"(<|$|>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"synInject"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[139,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[139,28]}},{"children":[],"comments":"Combines a printer/parser that consumes/returns a unit with another\nprinter/parser in a way that the unit is dropped instead of becoming part\nof a tuple, as it would with `<|*|>`\n\n    u :: syntax Unit\n    a :: syntax a\n    u *|> a :: syntax a\n","title":"(*|>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"dropUnitLeft"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[152,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[152,29]}}]}],"name":"Data.Intertwine.Route","comments":null,"declarations":[{"children":[{"comments":null,"title":"routeEmpty","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"TypeVar","contents":"r"}},"sourceSpan":{"start":[39,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[39,20]}},{"comments":null,"title":"routeSegments","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Lens","Types"],"Lens'"]},{"annotation":[],"tag":"TypeVar","contents":"r"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}}]}},"sourceSpan":{"start":[40,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[40,44]}},{"comments":null,"title":"routeQueryString","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Lens","Types"],"Lens'"]},{"annotation":[],"tag":"TypeVar","contents":"r"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Foreign","Object"],"Object"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}}]}},"sourceSpan":{"start":[41,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[41,52]}},{"comments":null,"title":"pathIsRoute","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route"],"IsRoute"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route"],"PathInfo"]}]}},"sourceSpan":{"start":[48,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[48,41]}}],"comments":"This class abstracts the idea of the \"route\" data type, making it possible\nfor the primitive in this module to work with data types from other\nlibraries.\n","title":"IsRoute","info":{"fundeps":[],"arguments":[["r",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[38,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[41,52]}},{"children":[{"comments":null,"title":"PathInfo","info":{"arguments":[{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Foreign","Object"],"Object"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"pathIsRoute","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route"],"IsRoute"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route"],"PathInfo"]}]}},"sourceSpan":{"start":[48,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[48,41]}}],"comments":"The default representation of a route: here the route is represented as a\nsequence of path segments and a dictionary of querystring parameters.\n","title":"PathInfo","info":{"declType":"data","dataDeclType":"data","typeArguments":[]},"sourceSpan":{"start":[46,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[46,60]}},{"children":[],"comments":"Syntax definition for a set of routes of type `a`.\n","title":"RoutesDef","info":{"arguments":[["route",null],["a",null]],"declType":"typeSynonym","type":{"annotation":[],"tag":"ForAll","contents":["syntax",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Syntax"],"Syntax"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"syntax"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]}},"sourceSpan":{"start":[55,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[55,72]}},{"children":[],"comments":null,"title":"parseRoute","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["route",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Route"],"IsRoute"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"route"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route"],"RoutesDef"]},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]}},"sourceSpan":{"start":[57,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[57,85]}},{"children":[],"comments":null,"title":"printRoute","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["route",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Route"],"IsRoute"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"route"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route"],"RoutesDef"]},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"route"}]}]}]}]},null]},null]}},"sourceSpan":{"start":[63,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[63,85]}},{"children":[],"comments":"Signifies the end of the route. During printing doesn't produce any output,\nduring parsing makes sure that there are no URL segments remaining.\n","title":"end","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["route",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Route"],"IsRoute"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"route"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route"],"RoutesDef"]},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},null]}},"sourceSpan":{"start":[68,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[68,59]}},{"children":[],"comments":"Path segment that is a literal string. During printing outputs the given\nstring, during parsing consumes the next URL segment and makes sure it's\nequal to the given string.\n","title":"seg","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["route",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Route"],"IsRoute"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"route"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route"],"RoutesDef"]},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]}]},null]}},"sourceSpan":{"start":[78,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[78,69]}},{"children":[],"comments":"A value of the given type as URL segment. During printing, the printer\noutputs the value as a URL segment, using the provided printing function to\nconvert it to a string. During parsing, the parser consumes a URL segment\nand tries to parse it into a value of the given type using the provided\nparsing function.\n","title":"segValue'","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["route",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Route"],"IsRoute"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"route"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route"],"RoutesDef"]},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]}},"sourceSpan":{"start":[112,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[115,25]}},{"children":[],"comments":"A value of the given type as URL segment. During printing, the printer\noutputs the value as a URL segment, using the `PathPiece` instance to\nconvert it to a string. During parsing, the parser consumes a URL segment\nand tries to parse it into a value of the given type using the `PathPiece`\ninstance.\n","title":"segValue","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["route",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Route"],"IsRoute"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"route"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Route","PathPiece"],"PathPiece"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route"],"RoutesDef"]},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]}},"sourceSpan":{"start":[104,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[104,78]}},{"children":[],"comments":"A primitive that encodes a constant value. During printing, the printer\nsucceeds iff the value beign printed is equal to `theValue`, otherwise\nfails. During parsing, the parser returns `theValue` without consuming any\ninput.\n","title":"constValue","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["route",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Eq"],"Eq"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route"],"RoutesDef"]},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]}},"sourceSpan":{"start":[92,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[92,61]}},{"children":[],"comments":"QueryString value. During printing adds the printed value (converted via\nthe given printing function) to the QueryString under given key. During\nparsing, looks up the value in the QueryString and attempts to parse it\nwith the given parsing function.\n","title":"query'","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["route",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Route"],"IsRoute"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"route"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route"],"RoutesDef"]},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]}]}]},null]},null]}},"sourceSpan":{"start":[135,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[139,33]}},{"children":[],"comments":"QueryString value. During printing adds the printed value to the\nQueryString under given key. During parsing, looks up the value in the\nQueryString.\n","title":"query","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["route",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Route"],"IsRoute"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"route"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Route","PathPiece"],"PathPiece"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route"],"RoutesDef"]},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]}]}]}]},null]},null]}},"sourceSpan":{"start":[128,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route.purs","end":[128,93]}}]},{"reExports":[],"name":"Data.Intertwine.Route.PathPiece","comments":null,"declarations":[{"children":[{"comments":null,"title":"toPathSegment","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}},"sourceSpan":{"start":[15,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route\\PathPiece.purs","end":[15,33]}},{"comments":null,"title":"fromPathSegment","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":{"start":[16,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route\\PathPiece.purs","end":[16,41]}},{"comments":null,"title":"pathPieceString","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route","PathPiece"],"PathPiece"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}},"sourceSpan":{"start":[18,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route\\PathPiece.purs","end":[18,45]}},{"comments":null,"title":"pathPieceInt","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Route","PathPiece"],"PathPiece"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[22,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route\\PathPiece.purs","end":[22,39]}}],"comments":"This class makes a type suitable for participating in route\nprinting/parsing - i.e. to be the type of path segments and querystring\nparameters.\n","title":"PathPiece","info":{"fundeps":[],"arguments":[["a",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[14,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Route\\PathPiece.purs","end":[16,41]}}]},{"reExports":[],"name":"Data.Intertwine.Syntax","comments":null,"declarations":[{"children":[{"comments":null,"title":"atom","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[119,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[119,85]}},{"comments":null,"title":"synApply","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[120,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[120,95]}},{"comments":null,"title":"synInject","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"ForAll","contents":["b",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Iso"],"Iso"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"b"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[121,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[121,79]}},{"comments":null,"title":"alt","info":{"declType":"typeClassMember","type":{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]},null]}},"sourceSpan":{"start":[122,5],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[122,78]}},{"comments":null,"title":"printerSyntax","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Syntax"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Printer"]}]}},"sourceSpan":{"start":[206,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[206,41]}},{"comments":null,"title":"parserSyntax","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Syntax"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Parser"]}]}},"sourceSpan":{"start":[237,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[237,39]}}],"comments":"An implementation of reversible printer-parser.\n\nThe goal is to provide the means for expressing representation of data\nstructures in a way that allows the same representation to be used for both\nparsing and printing, thus eliminating the need for code duplication and\nensuring that the printer and the parser don't diverge.\n\nThe type variable `syntax` here represents either a printer or a parser\n(see instances below). This printer-or-parser type, in turn, takes two\ngeneric parameters: parsing/printing state and the value being\nparsed/printed.\n\nThe thought process goes like this: first, we realize that all data is\nrepresentable as sum types, so we limit ourselves to working with sum\ntypes, or at least with something functionally equivalent.\n\nNext, since our syntax has to convert the value both ways, it follows that\nwe need, for every constructor of the sum type, a way to convert from its\nparameters to the type and back again. This concept is represented by the\npartial isomorphisms defined in ./Iso.purs (partial, because the conversion\nis not always possible). These isomorphisms are then automatically\ngenerated for each constructor via `Generic` - this generation code is in\n./MkIso.purs\n\nOnce we have an isomorphism for a constructor, it is tempting to follow the\nfamiliar parser structure:\n\n     data Foo = Foo Int String\n     parseFoo = Foo <$> parseInt <*> parseString\n\nHowever, the usual Functor style won't work here, because our syntax needs\nnot only to produce values (which is what Functors handle), but also to\n_consume_ them.\n\nIn order to do that, we work the other way around - instead of gradually\naccumulating the partially applied function within the functor from left to\nright, we work from from right to left, first accumulating all the\nparsers/printers that need to be \"applied\" to the constructor, and only\nthen injecting the constructor itself.\n\nThus:\n\n    pa :: Printer a\n    pb :: Printer b\n    pa `synApply` pb :: Printer (a, b)\n\nCombining the two printers gives us a printer that can print a tuple (same\nfor parsers). After that, such printer can be applied to the\nconstructor-derived Iso:\n\n    p :: Printer (a, b)\n    i :: Iso (a, b) T\n    i `synInject` p :: Printer T\n\nTo accomodate this, we generate the Iso instances for every constructor in\nsuch a way that converts the constructor's parameters into tuples, e.g.:\n\n    data T = A Int String | B Int String Boolean\n    iso \"A\"  :: Iso (Int, String) T\n    iso \"B\"  :: Iso (Int, (String, Boolean)) T\n\nThis structure nicely matches the structure that results from repeatedly\n`synApply`ing printers/parsers, provided both `synApply` and `synInject`\nare right-associative:\n\n    pInt :: Printer Int\n    pString :: Printer String\n    pBoolean :: Printer Boolean\n    (iso \"B\") `synInject` pInt `synApply` pString `synApply` pBoolean\n\nThe `alt` operation allows to combine multiple printers/parsers and try\nthem out in order - very similar to the (<|>) operator from `Control.Alt`.\n\nFinally, the `atom` operation can be used for creating primitive parsers by\nproviding an `Iso (state, a) (state, ())`. The meaning of such `Iso` is the\nfollowing. The signature of a printing function is `state -> a -> Maybe\nstate`, taken to mean that a printing function takes the state accumulated\nso far (e.g. a string that has been printed so far), then takes a value to\nbe printed, and returns new state. The `Maybe` indicates that printing may\nfail. Conversely, the signature of a parsing function is `state -> Maybe\n(a, state)`, taken to mean that the function takes the state (e.g. the tail\nof the input string that hasn't yet been consumed) and returns both the\nparsed value and the new state (e.g. the new string tail, after consuming\nwhatever was needed to parse the value). To recap:\n\n      print :: state -> a -> Maybe state\n      parse :: state -> Maybe (a, state)\n\nApplying isomorphic manipulations to the signature - specifically,\nuncurrying the arguments, commuting tuples, and noting that `x` is\nisomorphic to `(x,())` - we can get:\n\n      print :: (state, a) -> Maybe (state, ())\n      parse :: (state, ()) -> Maybe (state, a)\n\nWhich is equivalent to `Iso (state, a) (state, ())`. Thus, we can treat an\n`Iso` as a pair of print+parse functions, and thus we can use it to\nconstruct a primitive parser/printer.\n","title":"Syntax","info":{"fundeps":[],"arguments":[["syntax",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[118,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[122,78]}},{"children":[],"comments":"Combines two printers/parsers together, iyelding a printer/parser that can\nprint/parse a tuple of the two combined values.\n\n    a :: syntax a\n    b :: syntax b\n    a <|*|> b :: syntax (a, b)\n","title":"(<|*|>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"synApply"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[131,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[131,27]}},{"children":[],"comments":"Injects an `Iso` into a printer/parser on the right side, producing a\nprinter/parser of the type that is left type of the `Iso`.\n\n    i :: Iso a (b, (c, d))\n    p :: syntax (b, (c, d))\n    i <|$|> p :: syntax a\n","title":"(<|$|>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"synInject"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[139,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[139,28]}},{"children":[],"comments":"Combines two printers/parsers of the same type in a way that first attempts\nthe left one, and if it fails, falls back to the right.\n","title":"(<|||>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"alt"}}}],"fixity":{"associativity":"infixl","precedence":2}},"sourceSpan":{"start":[143,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[143,22]}},{"children":[],"comments":"Combines two printers/parsers similarly to `synApply`, but ignoring the\nleft printer/parser, provided it returns/consumes a unit.\n","title":"dropUnitLeft","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"ForAll","contents":["syntax",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Syntax"],"Syntax"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"syntax"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[156,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[156,110]}},{"children":[],"comments":"Combines a printer/parser that consumes/returns a unit with another\nprinter/parser in a way that the unit is dropped instead of becoming part\nof a tuple, as it would with `<|*|>`\n\n    u :: syntax Unit\n    a :: syntax a\n    u *|> a :: syntax a\n","title":"(*|>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"dropUnitLeft"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[152,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[152,29]}},{"children":[],"comments":"Combines two printers/parsers similarly to `synApply`, but ignoring the\nright printer/parser, provided it returns/consumes a unit.\n","title":"dropUnitRight","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"ForAll","contents":["syntax",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Syntax"],"Syntax"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"syntax"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[171,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[171,111]}},{"children":[],"comments":"Combines a printer/parser that consumes/returns a unit with another\nprinter/parser in a way that the unit is dropped instead of becoming part\nof a tuple, as it would with `<|*|>`\n\n    u :: syntax Unit\n    a :: syntax a\n    a <|* u :: syntax a\n","title":"(<|*)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"dropUnitRight"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[167,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[167,30]}},{"children":[{"comments":null,"title":"Ctor","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null}],"comments":"This type is equivalent to `SProxy`, but provided here separately for the\npurpose of shortening the code in combination with the `<|:|>` operator\n(see comments there).\n","title":"Ctor","info":{"declType":"data","dataDeclType":"data","typeArguments":[["name",{"annotation":[],"tag":"NamedKind","contents":[["Prim"],"Symbol"]}]]},"sourceSpan":{"start":[179,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[179,34]}},{"children":[],"comments":"Meant to be used as infix operator `<|:|>`, see comments on it.\n","title":"injectConstructor","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["route",{"annotation":[],"tag":"ForAll","contents":["syntax",{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["args",{"annotation":[],"tag":"ForAll","contents":["name",{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","MkIso"],"MkIso"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"a"},{"annotation":[],"tag":"TypeVar","contents":"name"},{"annotation":[],"tag":"TypeVar","contents":"args"}],"constraintData":null},{"annotation":[],"tag":"ConstrainedType","contents":[{"constraintAnn":[],"constraintClass":[["Data","Intertwine","Syntax"],"Syntax"],"constraintArgs":[{"annotation":[],"tag":"TypeVar","contents":"syntax"}],"constraintData":null},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Ctor"]},{"annotation":[],"tag":"TypeVar","contents":"name"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"TypeVar","contents":"args"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeVar","contents":"syntax"},{"annotation":[],"tag":"TypeVar","contents":"route"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]}]}]},null]},null]},null]},null]},null]}},"sourceSpan":{"start":[195,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[195,141]}},{"children":[],"comments":"Binds a constructor, whose name is encoded in the `Ctor` value, to the\ngiven parser/printer.\n\nFor example:\n\n    data T = A String | B (Maybe Int)\n\n    syntax =\n             (Ctor::Ctor \"A\") <|:|> value\n       <|||> (Ctor::Ctor \"B\") <|:|> query \"id\"\n\n","title":"(<|:|>)","info":{"declType":"alias","alias":[["Data","Intertwine","Syntax"],{"Right":{"Left":{"Ident":"injectConstructor"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[192,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[192,36]}},{"children":[{"comments":null,"title":"printerSyntax","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Syntax"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Printer"]}]}},"sourceSpan":{"start":[206,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[206,41]}}],"comments":"An implementation of `Syntax` for printing.\n","title":"Printer","info":{"declType":"data","dataDeclType":"newtype","typeArguments":[["state",null],["a",null]]},"sourceSpan":{"start":[204,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[204,65]}},{"children":[],"comments":"Runs a reversible syntax definition for printing, given an initial printer\nstate.\n\nThe first parameter is supposed to be a polymorphic reversible definition\nsuch as:\n\n    s :: forall syntax. Syntax syntax => syntax a b\n\nPassing such parameter to this function would instantiate the `syntax` type\nvariable to `Printer`, and the printing will commence.\n","title":"print","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Printer"]},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"TypeVar","contents":"state"}]}]}]}]},null]},null]}},"sourceSpan":{"start":[226,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[226,70]}},{"children":[{"comments":null,"title":"parserSyntax","info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Syntax"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Parser"]}]}},"sourceSpan":{"start":[237,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[237,39]}}],"comments":"An implementation of `Syntax` for parsing.\n","title":"Parser","info":{"declType":"data","dataDeclType":"newtype","typeArguments":[["state",null],["a",null]]},"sourceSpan":{"start":[235,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[235,65]}},{"children":[],"comments":"Runs a reversible syntax definition for parsing, given an initial parser\nstate.\n\nThe first parameter is supposed to be a polymorphic reversible definition\nsuch as:\n\n    s :: forall syntax. Syntax syntax => syntax a b\n\nPassing such parameter to this function would instantiate the `syntax` type\nvariable to `Parser`, and the parsing will commence.\n","title":"parse","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"ForAll","contents":["state",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Syntax"],"Parser"]},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeVar","contents":"state"}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Maybe"],"Maybe"]},{"annotation":[],"tag":"ParensInType","contents":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]},{"annotation":[],"tag":"TypeVar","contents":"state"}]}}]}]}]},null]},null]}},"sourceSpan":{"start":[259,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Syntax.purs","end":[259,74]}}]},{"reExports":[],"name":"Data.Intertwine.Text","comments":"Syntax primitives for printing/parsing plain text\n","declarations":[{"children":[],"comments":null,"title":"str","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Text"],"Primitive"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}},"sourceSpan":{"start":[38,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Text.purs","end":[38,24]}},{"children":[],"comments":null,"title":"followedBy","info":{"declType":"value","type":{"annotation":[],"tag":"ForAll","contents":["a",{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Text"],"Primitive"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Text"],"Primitive"]},{"annotation":[],"tag":"TypeVar","contents":"a"}]}]}]},null]}},"sourceSpan":{"start":[23,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Text.purs","end":[23,61]}},{"children":[],"comments":null,"title":"int","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Text"],"Primitive"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[44,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Text.purs","end":[44,21]}},{"children":[],"comments":null,"title":"lit","info":{"declType":"value","type":{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"annotation":[],"tag":"TypeApp","contents":[{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Intertwine","Text"],"Primitive"]},{"annotation":[],"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]}},"sourceSpan":{"start":[56,1],"name":"C:\\w\\intertwine\\src\\Data\\Intertwine\\Text.purs","end":[56,32]}}]}],"resolvedDependencies":{"purescript-free":"5.2.0","purescript-proxy":"3.0.0","purescript-exceptions":"4.0.0","purescript-newtype":"3.0.0","purescript-effect":"2.0.1","purescript-ordered-collections":"1.6.1","purescript-unicode":"4.0.1","purescript-control":"4.1.0","purescript-console":"4.2.0","purescript-either":"4.1.1","purescript-profunctor":"4.0.0","purescript-arrays":"5.3.0","purescript-maybe":"4.0.1","purescript-profunctor-lenses":"4.0.0","purescript-type-equality":"3.0.0","purescript-exists":"4.0.0","purescript-distributive":"4.0.0","purescript-unfoldable":"4.0.0","purescript-invariant":"4.1.0","purescript-lcg":"2.0.0","purescript-lazy":"4.0.0","purescript-foreign-object":"1.1.0","purescript-aff":"5.1.1","purescript-foldable-traversable":"4.1.1","purescript-tailrec":"4.0.0","purescript-gen":"2.1.1","purescript-typelevel-prelude":"3.0.0","purescript-functors":"3.1.1","purescript-prelude":"4.1.1","purescript-st":"4.0.0","purescript-bifunctors":"4.0.0","purescript-pipes":"6.0.0","purescript-nonempty":"5.0.0","purescript-contravariant":"4.0.1","purescript-unsafe-coerce":"4.0.0","purescript-refs":"4.1.0","purescript-integers":"4.0.0","purescript-mmorph":"5.1.0","purescript-ansi":"5.0.0","purescript-orders":"4.0.0","purescript-const":"4.1.0","purescript-spec":"3.1.0","purescript-record":"1.0.0","purescript-transformers":"4.2.0","purescript-globals":"4.0.0","purescript-generics-rep":"6.1.1","purescript-math":"2.1.1","purescript-enums":"4.0.1","purescript-psci-support":"4.0.0","purescript-catenable-lists":"5.0.1","purescript-random":"4.0.0","purescript-parallel":"4.0.0","purescript-tuples":"5.1.0","purescript-spec-quickcheck":"3.1.0","purescript-partial":"2.0.1","purescript-quickcheck":"5.0.0","purescript-strings":"4.0.1","purescript-identity":"4.1.0","purescript-foreign":"5.0.0","purescript-lists":"5.4.0","purescript-datetime":"4.1.1","purescript-functions":"4.0.0"},"version":"0.4.2","github":["collegevine","purescript-intertwine"],"versionTag":"v0.4.2","moduleMap":{"Data.BooleanAlgebra":"purescript-prelude","Ansi.Output":"purescript-ansi","Data.Decide":"purescript-contravariant","Type.Data.Boolean":"purescript-typelevel-prelude","Data.Ring":"purescript-prelude","Record.ST":"purescript-record","Control.Monad.Trans.Class":"purescript-transformers","Record.Unsafe.Union":"purescript-record","Data.Functor.Product":"purescript-functors","Foreign.Keys":"purescript-foreign","Data.NonEmpty":"purescript-nonempty","Test.Spec.Console":"purescript-spec","Effect.Uncurried":"purescript-effect","Data.Char.Gen":"purescript-strings","Data.String.NonEmpty":"purescript-strings","Effect":"purescript-effect","Data.Traversable.Accum.Internal":"purescript-foldable-traversable","Data.Enum.Gen":"purescript-enums","Control.Comonad.Env":"purescript-transformers","Control.Comonad.Traced.Class":"purescript-transformers","Test.Spec.Summary":"purescript-spec","Data.Functor.Compose":"purescript-functors","Foreign.Object.Gen":"purescript-foreign-object","Type.Row.Homogeneous":"purescript-typelevel-prelude","Data.Int.Bits":"purescript-integers","Data.DateTime":"purescript-datetime","Data.Bifunctor.Flip":"purescript-bifunctors","Data.String.CodePoints":"purescript-strings","Data.Ord":"purescript-prelude","Control.Monad.Gen":"purescript-gen","Control.Monad.Free.Class":"purescript-free","Type.Data.Row":"purescript-prelude","Data.Date":"purescript-datetime","Control.Comonad.Cofree.Class":"purescript-free","Data.Monoid.Dual":"purescript-prelude","Data.Generic.Rep.Ring":"purescript-generics-rep","Control.Monad.Rec.Class":"purescript-tailrec","Data.Time.Component":"purescript-datetime","Data.Lens":"purescript-profunctor-lenses","Data.Bitraversable":"purescript-foldable-traversable","Data.Profunctor.Costar":"purescript-profunctor","Data.Profunctor.Cowrap":"purescript-profunctor","Record.Builder":"purescript-record","Data.Boolean":"purescript-prelude","Data.Map":"purescript-ordered-collections","Control.Biapplicative":"purescript-bifunctors","Data.CatList":"purescript-catenable-lists","Effect.Exception.Unsafe":"purescript-exceptions","Control.Parallel.Class":"purescript-parallel","Data.Array.NonEmpty.Internal":"purescript-arrays","Type.Proxy":"purescript-proxy","Pipes.Core":"purescript-pipes","Data.Coyoneda":"purescript-free","Effect.Aff.Compat":"purescript-aff","Data.Array.ST.Iterator":"purescript-arrays","Data.DateTime.Gen":"purescript-datetime","Data.Lens.Prism.Maybe":"purescript-profunctor-lenses","Test.Spec.Assertions.Aff":"purescript-spec","Data.String.Pattern":"purescript-strings","Data.Bounded":"purescript-prelude","Control.Monad.State.Trans":"purescript-transformers","Data.TraversableWithIndex":"purescript-foldable-traversable","Data.Int":"purescript-integers","Data.Lens.Internal.Grating":"purescript-profunctor-lenses","Data.Profunctor.Cochoice":"purescript-profunctor","Data.Show":"purescript-prelude","Random.LCG":"purescript-lcg","Data.Bifunctor.Clown":"purescript-bifunctors","Control.Monad.Writer.Trans":"purescript-transformers","Data.Foldable":"purescript-foldable-traversable","Data.Divide":"purescript-contravariant","Control.Comonad.Store.Class":"purescript-transformers","Data.Enum":"purescript-enums","Control.Monad.Trampoline":"purescript-free","Foreign.Object":"purescript-foreign-object","Control.Apply":"purescript-prelude","Data.Functor.Contravariant":"purescript-contravariant","Data.Tuple.Nested":"purescript-tuples","Data.Generic.Rep.Semigroup":"purescript-generics-rep","Data.Lens.Lens.Product":"purescript-profunctor-lenses","Control.Monad":"purescript-prelude","Data.Lazy":"purescript-lazy","Data.Monoid":"purescript-prelude","Data.Profunctor.Closed":"purescript-profunctor","Control.Monad.List.Trans":"purescript-transformers","Control.Monad.RWS":"purescript-transformers","Data.String.Common":"purescript-strings","Data.Maybe.First":"purescript-maybe","Control.Bind":"purescript-prelude","Data.Profunctor.Split":"purescript-profunctor","Effect.Aff.Class":"purescript-aff","Data.Monoid.Additive":"purescript-prelude","Data.Symbol":"purescript-prelude","Data.Lens.Prism.Coproduct":"purescript-profunctor-lenses","Data.Map.Gen":"purescript-ordered-collections","Data.Lens.Lens":"purescript-profunctor-lenses","Data.String.Regex":"purescript-strings","Data.Profunctor.Join":"purescript-profunctor","Data.HeytingAlgebra":"purescript-prelude","Control.Alt":"purescript-control","Data.Date.Gen":"purescript-datetime","Control.Monad.Maybe.Trans":"purescript-transformers","Control.Monad.Cont":"purescript-transformers","Control.Monad.ST.Internal":"purescript-st","Type.Data.RowList":"purescript-prelude","Data.Time.Component.Gen":"purescript-datetime","Test.Spec.QuickCheck":"purescript-spec-quickcheck","Effect.Ref":"purescript-refs","Data.Either.Inject":"purescript-either","Foreign.Object.ST.Unsafe":"purescript-foreign-object","Data.Lens.Internal.Forget":"purescript-profunctor-lenses","Data.List.ZipList":"purescript-lists","Data.Ord.Min":"purescript-orders","Test.Spec.Runner":"purescript-spec","Data.Functor.Coproduct.Nested":"purescript-functors","Data.Ord.Unsafe":"purescript-prelude","Data.Semigroup":"purescript-prelude","Data.Array.NonEmpty":"purescript-arrays","Control.Monad.Reader":"purescript-transformers","Data.Const":"purescript-const","Data.Generic.Rep.Enum":"purescript-generics-rep","Data.Generic.Rep.Bounded":"purescript-generics-rep","Test.Spec.Reporter.Console":"purescript-spec","Control.Comonad.Traced.Trans":"purescript-transformers","Data.Lens.Indexed":"purescript-profunctor-lenses","Test.Spec.Reporter.Dot":"purescript-spec","Data.Ord.Down":"purescript-orders","Data.Array.ST.Partial":"purescript-arrays","Data.Generic.Rep.Show":"purescript-generics-rep","Effect.Unsafe":"purescript-effect","Data.Profunctor.Clown":"purescript-profunctor","Data.Lens.Zoom":"purescript-profunctor-lenses","Data.Lens.Iso.Newtype":"purescript-profunctor-lenses","Pipes.Internal":"purescript-pipes","Control.Monad.Morph":"purescript-mmorph","Type.Data.Ordering":"purescript-typelevel-prelude","Data.Lens.Internal.Wander":"purescript-profunctor-lenses","Data.Tuple":"purescript-tuples","Data.Semigroup.Foldable":"purescript-foldable-traversable","Control.Biapply":"purescript-bifunctors","Data.Distributive":"purescript-distributive","Effect.Exception":"purescript-exceptions","Type.Equality":"purescript-type-equality","Foreign.Index":"purescript-foreign","Control.Alternative":"purescript-control","Data.Lens.Lens.Tuple":"purescript-profunctor-lenses","Data.Semiring":"purescript-prelude","Pipes.Prelude":"purescript-pipes","Data.Exists":"purescript-exists","Data.Char.Unicode.Internal":"purescript-unicode","Effect.Console":"purescript-console","Data.Traversable.Accum":"purescript-foldable-traversable","Data.CommutativeRing":"purescript-prelude","Data.NaturalTransformation":"purescript-prelude","Data.Monoid.Conj":"purescript-prelude","Data.Yoneda":"purescript-free","Data.Functor.App":"purescript-functors","Data.Lens.Internal.Exchange":"purescript-profunctor-lenses","Data.Profunctor.Star":"purescript-profunctor","Data.Unfoldable":"purescript-unfoldable","Data.Profunctor.Wrap":"purescript-profunctor","Control.Comonad.Store.Trans":"purescript-transformers","Test.Spec.Assertions.String":"purescript-spec","Foreign.Object.Unsafe":"purescript-foreign-object","Control.Monad.ST":"purescript-st","Control.Monad.State.Class":"purescript-transformers","Data.Lens.Internal.Shop":"purescript-profunctor-lenses","Data.Lens.Internal.Tagged":"purescript-profunctor-lenses","Data.Lens.Record":"purescript-profunctor-lenses","Data.List.Types":"purescript-lists","Data.String.NonEmpty.CodeUnits":"purescript-strings","Data.Functor":"purescript-prelude","Unsafe.Coerce":"purescript-unsafe-coerce","Control.Monad.Writer.Class":"purescript-transformers","Data.Generic.Rep.Ord":"purescript-generics-rep","Data.Lens.Grate":"purescript-profunctor-lenses","Data.Profunctor.Strong":"purescript-profunctor","Data.Lens.Internal.Market":"purescript-profunctor-lenses","Test.Spec.Reporter.Base":"purescript-spec","Data.CatQueue":"purescript-catenable-lists","Control.Monad.Except":"purescript-transformers","Data.Interval":"purescript-datetime","Data.List.Lazy.Types":"purescript-lists","Control.Category":"purescript-prelude","Test.Spec.Reporter.Tap":"purescript-spec","Test.QuickCheck.Arbitrary":"purescript-quickcheck","Data.Lens.Common":"purescript-profunctor-lenses","Data.Lens.Getter":"purescript-profunctor-lenses","Data.Interval.Duration":"purescript-datetime","Control.Monad.Gen.Common":"purescript-gen","Control.Monad.RWS.Trans":"purescript-transformers","Test.Spec.Speed":"purescript-spec","Control.Monad.Cont.Trans":"purescript-transformers","Data.Maybe":"purescript-maybe","Type.Row":"purescript-typelevel-prelude","Data.String.Regex.Unsafe":"purescript-strings","Foreign.Object.ST":"purescript-foreign-object","Data.Set":"purescript-ordered-collections","Data.Profunctor":"purescript-profunctor","Control.Comonad":"purescript-control","Data.Function":"purescript-prelude","Data.List":"purescript-lists","Data.Lens.Traversal":"purescript-profunctor-lenses","Data.Field":"purescript-prelude","Data.List.Lazy":"purescript-lists","Data.Generic.Rep.Eq":"purescript-generics-rep","Data.EuclideanRing":"purescript-prelude","Data.Semigroup.Last":"purescript-prelude","Data.Semigroup.First":"purescript-prelude","Data.Functor.Invariant":"purescript-invariant","Data.Char.Unicode":"purescript-unicode","Control.Comonad.Traced":"purescript-transformers","Global.Unsafe":"purescript-globals","Data.Comparison":"purescript-contravariant","Data.String.Unsafe":"purescript-strings","Prelude":"purescript-prelude","Effect.Class":"purescript-effect","Data.Predicate":"purescript-contravariant","Partial.Unsafe":"purescript-partial","Data.Array":"purescript-arrays","Data.Bifunctor.Product":"purescript-bifunctors","Control.Extend":"purescript-control","Pipes":"purescript-pipes","Data.Unfoldable1":"purescript-unfoldable","Control.Lazy":"purescript-control","Data.Function.Uncurried":"purescript-functions","Control.Monad.Reader.Trans":"purescript-transformers","Data.Functor.Product.Nested":"purescript-functors","Data.Lens.Types":"purescript-profunctor-lenses","Pipes.ListT":"purescript-pipes","Control.Comonad.Env.Class":"purescript-transformers","Data.Interval.Duration.Iso":"purescript-datetime","Data.Eq":"purescript-prelude","Data.Either.Nested":"purescript-either","Control.Comonad.Cofree":"purescript-free","Data.Newtype":"purescript-newtype","Data.Semigroup.Traversable":"purescript-foldable-traversable","Test.Spec.Assertions":"purescript-spec","Data.Bifunctor":"purescript-bifunctors","Effect.Random":"purescript-random","Test.Spec.Reporter":"purescript-spec","Data.Monoid.Disj":"purescript-prelude","Control.Monad.Gen.Class":"purescript-gen","Data.Array.Partial":"purescript-arrays","Data.String.CaseInsensitive":"purescript-strings","Control.Monad.Free":"purescript-free","Control.Parallel":"purescript-parallel","Data.Lens.Index":"purescript-profunctor-lenses","Data.Lens.Internal.Re":"purescript-profunctor-lenses","Control.MonadPlus":"purescript-control","Data.Lens.Lens.Void":"purescript-profunctor-lenses","Data.Void":"purescript-prelude","Control.MonadZero":"purescript-control","Data.DateTime.Instant":"purescript-datetime","Data.Lens.Internal.Indexed":"purescript-profunctor-lenses","Data.Profunctor.Costrong":"purescript-profunctor","Data.Ord.Max":"purescript-orders","Control.Comonad.Store":"purescript-transformers","Control.Monad.Except.Trans":"purescript-transformers","Data.String.CodeUnits":"purescript-strings","Ansi.Codes":"purescript-ansi","Test.Spec":"purescript-spec","Data.Bifunctor.Joker":"purescript-bifunctors","Data.FunctorWithIndex":"purescript-foldable-traversable","Data.Divisible":"purescript-contravariant","Data.Lens.Fold":"purescript-profunctor-lenses","Data.Lens.Setter":"purescript-profunctor-lenses","Data.DivisionRing":"purescript-prelude","Record":"purescript-record","Data.Bifunctor.Wrap":"purescript-bifunctors","Data.Lens.Prism.Either":"purescript-profunctor-lenses","PSCI.Support":"purescript-psci-support","Data.Equivalence":"purescript-contravariant","Data.Maybe.Last":"purescript-maybe","Data.Unit":"purescript-prelude","Data.List.NonEmpty":"purescript-lists","Data.Generic.Rep.Semiring":"purescript-generics-rep","Data.List.Lazy.NonEmpty":"purescript-lists","Data.Ordering":"purescript-prelude","Data.Lens.Lens.Unit":"purescript-profunctor-lenses","Data.Functor.Coproduct":"purescript-functors","Control.Monad.Cont.Class":"purescript-transformers","Effect.Aff":"purescript-aff","Data.Identity":"purescript-identity","Data.Lens.Fold.Partial":"purescript-profunctor-lenses","Math":"purescript-math","Data.Set.NonEmpty":"purescript-ordered-collections","Control.Comonad.Trans.Class":"purescript-transformers","Data.String":"purescript-strings","Control.Plus":"purescript-control","Data.Profunctor.Joker":"purescript-profunctor","Test.QuickCheck":"purescript-quickcheck","Data.Map.Internal":"purescript-ordered-collections","Data.Time":"purescript-datetime","Data.Time.Duration":"purescript-datetime","Data.Date.Component":"purescript-datetime","Partial":"purescript-partial","Control.Comonad.Env.Trans":"purescript-transformers","Global":"purescript-globals","Control.Monad.Reader.Class":"purescript-transformers","Data.String.NonEmpty.CodePoints":"purescript-strings","Data.Decidable":"purescript-contravariant","Data.String.NonEmpty.Internal":"purescript-strings","Data.Monoid.Multiplicative":"purescript-prelude","Data.String.NonEmpty.CaseInsensitive":"purescript-strings","Type.Data.Symbol":"purescript-typelevel-prelude","Data.Array.ST":"purescript-arrays","Foreign":"purescript-foreign","Control.Monad.Error.Class":"purescript-transformers","Data.Generic.Rep.HeytingAlgebra":"purescript-generics-rep","Data.Generic.Rep.Monoid":"purescript-generics-rep","Control.Semigroupoid":"purescript-prelude","Data.Monoid.Alternate":"purescript-control","Data.Char":"purescript-strings","Data.Generic.Rep":"purescript-generics-rep","Effect.Class.Console":"purescript-console","Data.Bifunctor.Join":"purescript-bifunctors","Data.Lens.Internal.Zipping":"purescript-profunctor-lenses","Data.Bifoldable":"purescript-foldable-traversable","Control.Monad.ST.Ref":"purescript-st","Data.Monoid.Endo":"purescript-prelude","Test.Spec.Color":"purescript-spec","Control.Monad.State":"purescript-transformers","Data.List.Partial":"purescript-lists","Data.Lens.Prism":"purescript-profunctor-lenses","Test.Spec.Runner.Event":"purescript-spec","Data.String.Regex.Flags":"purescript-strings","Data.Either":"purescript-either","Data.Time.Duration.Gen":"purescript-datetime","Data.Date.Component.Gen":"purescript-datetime","Type.Prelude":"purescript-typelevel-prelude","Control.Applicative":"purescript-prelude","Data.Lens.Internal.Focusing":"purescript-profunctor-lenses","Data.Lens.Iso":"purescript-profunctor-lenses","Data.FoldableWithIndex":"purescript-foldable-traversable","Data.Op":"purescript-contravariant","Record.Unsafe":"purescript-prelude","Test.QuickCheck.Gen":"purescript-quickcheck","Data.Lens.At":"purescript-profunctor-lenses","Control.Monad.Writer":"purescript-transformers","Test.Spec.Reporter.Spec":"purescript-spec","Data.Functor.Coproduct.Inject":"purescript-functors","Data.Profunctor.Choice":"purescript-profunctor","Data.Time.Gen":"purescript-datetime","Data.Traversable":"purescript-foldable-traversable","Data.String.Gen":"purescript-strings"},"compilerVersion":"0.12.2"}