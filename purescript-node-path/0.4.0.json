{"uploader":"hdgarrood","packageMeta":{"homepage":"https://github.com/purescript-node/purescript-node-path","repository":{"url":"git://github.com/purescript-node/purescript-node-path.git","type":"git"},"ignore":["**/.*","bower_components","node_modules","output","bower.json","gulpfile.js","package.json"],"devDependencies":{"purescript-assert":"^0.1.0"},"name":"purescript-node-path","keywords":["purescript"],"license":["MIT"],"description":"PureScript type definitions for Node's path module"},"modules":[{"reExports":[],"name":"Node.Path","comments":null,"declarations":[{"children":[],"comments":"Type for strings representing file paths.\n","title":"FilePath","fixity":null,"info":{"arguments":[],"declType":"typeSynonym","type":{"tag":"TypeConstructor","contents":[["Prim"],"String"]}},"sourceSpan":{"start":[4,1],"name":"src/Node/Path.purs","end":[9,1]}},{"children":[],"comments":"Normalize a string path, taking care of `..` and `.`, duplicated slashes,\netc. If the path contains a trailing slash it is preserved. On Windows\nbackslashes are used.\n","title":"normalize","fixity":null,"info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]}},"sourceSpan":{"start":[9,1],"name":"src/Node/Path.purs","end":[12,1]}},{"children":[],"comments":"Concatenates multiple path segments together and normalizes the resulting path.\n","title":"concat","fixity":null,"info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]}]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]}},"sourceSpan":{"start":[12,1],"name":"src/Node/Path.purs","end":[15,1]}},{"children":[],"comments":"Resolves `to` to an absolute path ([from...], to).\n","title":"resolve","fixity":null,"info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]}]}},"sourceSpan":{"start":[15,1],"name":"src/Node/Path.purs","end":[18,1]}},{"children":[],"comments":"Solve the relative path from `from` to `to`.\n","title":"relative","fixity":null,"info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]}]}},"sourceSpan":{"start":[18,1],"name":"src/Node/Path.purs","end":[21,1]}},{"children":[],"comments":"Return the directory name of a path.\n","title":"dirname","fixity":null,"info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]}},"sourceSpan":{"start":[21,1],"name":"src/Node/Path.purs","end":[24,1]}},{"children":[],"comments":"Return the last portion of a path.\n","title":"basename","fixity":null,"info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]}},"sourceSpan":{"start":[24,1],"name":"src/Node/Path.purs","end":[28,1]}},{"children":[],"comments":"Return the last portion of a path, also dropping a specific file extension\nif it matches the end of the name.\n","title":"basenameWithoutExt","fixity":null,"info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]}]}},"sourceSpan":{"start":[28,1],"name":"src/Node/Path.purs","end":[33,1]}},{"children":[],"comments":"Return the extension of the path, from the last `.` to end of string in the\nlast portion of the path. If there is no `.` in the last portion of the\npath or the first character of it is `.`, then it returns an empty string.\n","title":"extname","fixity":null,"info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]},{"tag":"TypeConstructor","contents":[["Node","Path"],"FilePath"]}]}},"sourceSpan":{"start":[33,1],"name":"src/Node/Path.purs","end":[36,1]}},{"children":[],"comments":"The platform-specific file separator. `\\\\` or `/`.\n","title":"sep","fixity":null,"info":{"declType":"value","type":{"tag":"TypeConstructor","contents":[["Prim"],"String"]}},"sourceSpan":{"start":[36,1],"name":"src/Node/Path.purs","end":[39,1]}},{"children":[],"comments":"The platform-specific path delimiter, `;` or `:`.\n","title":"delimiter","fixity":null,"info":{"declType":"value","type":{"tag":"TypeConstructor","contents":[["Prim"],"String"]}},"sourceSpan":{"start":[39,1],"name":"src/Node/Path.purs","end":[39,29]}}]}],"resolvedDependencies":{"purescript-prelude":"0.1.5","purescript-assert":"0.1.1","purescript-eff":"0.1.2"},"bookmarks":[{"package":null,"item":["Node.Path","FilePath"]},{"package":null,"item":["Node.Path","normalize"]},{"package":null,"item":["Node.Path","concat"]},{"package":null,"item":["Node.Path","resolve"]},{"package":null,"item":["Node.Path","relative"]},{"package":null,"item":["Node.Path","dirname"]},{"package":null,"item":["Node.Path","basename"]},{"package":null,"item":["Node.Path","basenameWithoutExt"]},{"package":null,"item":["Node.Path","extname"]},{"package":null,"item":["Node.Path","sep"]},{"package":null,"item":["Node.Path","delimiter"]},{"package":"purescript-prelude","item":["Prelude","Unit"]},{"package":"purescript-prelude","item":["Prelude","unit"]},{"package":"purescript-prelude","item":["Prelude","($)"]},{"package":"purescript-prelude","item":["Prelude","(#)"]},{"package":"purescript-prelude","item":["Prelude","flip"]},{"package":"purescript-prelude","item":["Prelude","const"]},{"package":"purescript-prelude","item":["Prelude","asTypeOf"]},{"package":"purescript-prelude","item":["Prelude","otherwise"]},{"package":"purescript-prelude","item":["Prelude","Semigroupoid"]},{"package":"purescript-prelude","item":["Prelude","(<<<)"]},{"package":"purescript-prelude","item":["Prelude","(>>>)"]},{"package":"purescript-prelude","item":["Prelude","Category"]},{"package":"purescript-prelude","item":["Prelude","Functor"]},{"package":"purescript-prelude","item":["Prelude","(<$>)"]},{"package":"purescript-prelude","item":["Prelude","(<#>)"]},{"package":"purescript-prelude","item":["Prelude","void"]},{"package":"purescript-prelude","item":["Prelude","Apply"]},{"package":"purescript-prelude","item":["Prelude","(<*>)"]},{"package":"purescript-prelude","item":["Prelude","Applicative"]},{"package":"purescript-prelude","item":["Prelude","return"]},{"package":"purescript-prelude","item":["Prelude","liftA1"]},{"package":"purescript-prelude","item":["Prelude","Bind"]},{"package":"purescript-prelude","item":["Prelude","(>>=)"]},{"package":"purescript-prelude","item":["Prelude","Monad"]},{"package":"purescript-prelude","item":["Prelude","liftM1"]},{"package":"purescript-prelude","item":["Prelude","ap"]},{"package":"purescript-prelude","item":["Prelude","Semigroup"]},{"package":"purescript-prelude","item":["Prelude","(<>)"]},{"package":"purescript-prelude","item":["Prelude","(++)"]},{"package":"purescript-prelude","item":["Prelude","Semiring"]},{"package":"purescript-prelude","item":["Prelude","(+)"]},{"package":"purescript-prelude","item":["Prelude","(*)"]},{"package":"purescript-prelude","item":["Prelude","Ring"]},{"package":"purescript-prelude","item":["Prelude","(-)"]},{"package":"purescript-prelude","item":["Prelude","negate"]},{"package":"purescript-prelude","item":["Prelude","ModuloSemiring"]},{"package":"purescript-prelude","item":["Prelude","(/)"]},{"package":"purescript-prelude","item":["Prelude","DivisionRing"]},{"package":"purescript-prelude","item":["Prelude","Num"]},{"package":"purescript-prelude","item":["Prelude","Eq"]},{"package":"purescript-prelude","item":["Prelude","(==)"]},{"package":"purescript-prelude","item":["Prelude","(/=)"]},{"package":"purescript-prelude","item":["Prelude","Ordering"]},{"package":"purescript-prelude","item":["Prelude","Ord"]},{"package":"purescript-prelude","item":["Prelude","(<)"]},{"package":"purescript-prelude","item":["Prelude","(>)"]},{"package":"purescript-prelude","item":["Prelude","(<=)"]},{"package":"purescript-prelude","item":["Prelude","(>=)"]},{"package":"purescript-prelude","item":["Prelude","unsafeCompare"]},{"package":"purescript-prelude","item":["Prelude","Bounded"]},{"package":"purescript-prelude","item":["Prelude","BoundedOrd"]},{"package":"purescript-prelude","item":["Prelude","BooleanAlgebra"]},{"package":"purescript-prelude","item":["Prelude","(&&)"]},{"package":"purescript-prelude","item":["Prelude","(||)"]},{"package":"purescript-prelude","item":["Prelude","Show"]},{"package":"purescript-eff","item":["Control.Monad.Eff","Eff"]},{"package":"purescript-eff","item":["Control.Monad.Eff","Pure"]},{"package":"purescript-eff","item":["Control.Monad.Eff","runPure"]},{"package":"purescript-eff","item":["Control.Monad.Eff","untilE"]},{"package":"purescript-eff","item":["Control.Monad.Eff","whileE"]},{"package":"purescript-eff","item":["Control.Monad.Eff","forE"]},{"package":"purescript-eff","item":["Control.Monad.Eff","foreachE"]},{"package":"purescript-eff","item":["Control.Monad.Eff.Unsafe","unsafeInterleaveEff"]},{"package":"purescript-eff","item":["Control.Monad.Eff.Unsafe","unsafePerformEff"]},{"package":"purescript-eff","item":["Control.Monad.Eff.Class","MonadEff"]},{"package":"purescript-assert","item":["Test.Assert","ASSERT"]},{"package":"purescript-assert","item":["Test.Assert","assert"]},{"package":"purescript-assert","item":["Test.Assert","assert'"]},{"package":"purescript-assert","item":["Test.Assert","assertThrows"]},{"package":"purescript-assert","item":["Test.Assert","assertThrows'"]}],"version":"0.4.0","github":["purescript-node","purescript-node-path"],"versionTag":"v0.4.0","compilerVersion":"0.8.5.0"}