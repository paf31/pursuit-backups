{"uploader":"i-am-tom","packageMeta":{"repository":{"url":"git://github.com/i-am-tom/purescript-prelewd.git","type":"git"},"ignore":["**/.*","node_modules","bower_components","output"],"devDependencies":{"purescript-psci-support":"^3.0.0"},"dependencies":{"purescript-control":"^3.3.0","purescript-console":"^3.0.0","purescript-either":"^3.1.0","purescript-pairs":"^5.0.0","purescript-debug":"^3.0.0","purescript-prelude":"^3.1.0"},"name":"purescript-prelewd","license":["MIT"]},"tagTime":"2017-08-07T19:50:27+0000","modules":[{"reExports":[],"name":"Prelewd","comments":null,"declarations":[{"children":[],"comments":"I've chosen a train as you might thing of it as the second thing going\nthrough a \"magic tunnel\" that transforms its passengers. Bear with me: this\nwill make more sense in a second.\n","title":"(üöÇ)","info":{"declType":"alias","alias":[["Data","Functor"],{"Right":{"Left":{"Ident":"map"}}}],"fixity":{"associativity":"infixl","precedence":4}},"sourceSpan":{"start":[18,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[18,18]}},{"children":[],"comments":"You may, from time to time, see some code like `f <$> a <*> b <*> c`. What\nthis does is apply three (specifically `Apply`) *functor-wrapped* values to\n`f`, and returns the answer wrapped up in the same `Apply`. To make this\nclearer, `Prelewd` would write this as `f üöÇ(a)üöã(b)üöã(c)`. We can now see\nthat what we're actually doing is driving our train through the \"magic\ntunnel\" with some extra passengers. We are effectively combining `a`, `b`,\nand `c` using the `f` function to bring them all together.\n","title":"(üöã)","info":{"declType":"alias","alias":[["Control","Apply"],{"Right":{"Left":{"Ident":"apply"}}}],"fixity":{"associativity":"infixl","precedence":4}},"sourceSpan":{"start":[27,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[27,22]}},{"children":[],"comments":"Particularly with things like validation, you'll get code sequences like\n`isUpper name *> pure name`, where `Either` is the underlying mechanism.\nWhat's going on here is that the values are combined with `\\x y -> y`,\nwhich means that any \"side-effects\" from the first value aren't forgotten.\nSo, for validation, this means that any validation *failure* is carried\nforward. Or, in `Prelewd`, we use the _now-look-at-that-one_ operator.\n","title":"(üëâ)","info":{"declType":"alias","alias":[["Control","Apply"],{"Right":{"Left":{"Ident":"applySecond"}}}],"fixity":{"associativity":"infixl","precedence":4}},"sourceSpan":{"start":[35,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[35,28]}},{"children":[],"comments":"I desperately wanted to use üåØ for this, and I probably will as soon as the\ncompiler starts handling the weird emoji set. For now, though, I'm going to\nuse this explosion thing. The point is that stuff (well, air) goes in one\nend, and gets transformed into noise or whatever. _Stretched metaphor_. The\npoint is that confetti and stuff happens as a side-effect. `>>=` is scary,\nbut üéâ is delightful. `readLine üéâ log` means \"pass the input to `log`, and\nthrow confetti everywhere in the process\".\n","title":"(üéâ)","info":{"declType":"alias","alias":[["Control","Bind"],{"Right":{"Left":{"Ident":"bind"}}}],"fixity":{"associativity":"infixl","precedence":1}},"sourceSpan":{"start":[44,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[44,19]}},{"children":[],"comments":"In the early days, composition is a confusing thing to read. When we write,\n`f <<< g`, what we actually get is `\\x -> f (g x)`. When we write something\nlike, `f <<< g <<< h`, we get `\\x -> f (g (h x))`. PureScript's syntax\nactually makes this pretty straightforward already, with some pretty clear\ndirection to these operators, but this is prelewd, so let's bung in some\nmore emojis.\n","title":"(üîô)","info":{"declType":"alias","alias":[["Control","Semigroupoid"],{"Right":{"Left":{"Ident":"compose"}}}],"fixity":{"associativity":"infixr","precedence":9}},"sourceSpan":{"start":[52,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[52,22]}},{"children":[],"comments":"For people coming from Elm and most imperative languages, it probably seems\na bit more familiar to see composition the other way round. Don't worry: we\ngot your back, friends. At least for iOS, this arrow is labelled `SOON`, so\nthat's quite exciting!\n","title":"(üîú)","info":{"declType":"alias","alias":[["Control","Semigroupoid"],{"Right":{"Left":{"Ident":"composeFlipped"}}}],"fixity":{"associativity":"infixr","precedence":9}},"sourceSpan":{"start":[58,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[58,29]}},{"children":[],"comments":"`$` is waaay less frightening than it looks at first. The idea is that you\ntake the result of everything on the left, and apply it to the result of\neverything on the right. So, `f x $ g x` is actually `(f x) (g x)`. That's\nall there is to it! With the exception of brackets/parentheses, this is a\nwill be the very last thing to evaluate, so you can make the sides as weird\nas you like. The gust of wind is to show the sides being \"blown apart\" to\nwork separately, before being recombined at the end!\n","title":"(üí®)","info":{"declType":"alias","alias":[["Data","Function"],{"Right":{"Left":{"Ident":"apply"}}}],"fixity":{"associativity":"infixr","precedence":0}},"sourceSpan":{"start":[67,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[67,20]}},{"children":[],"comments":"It's quite a transformation. You'll see `~>` every now and then in types.\nFor example, `Array ~> Maybe`. Fear not: this expands to the more friendly,\n`type NaturalTransformation f g = forall a. f a -> g a`. In other words,\n`Array ~> Maybe` is a function that takes an array of *any* type, and turns\nit into a `Maybe` of *the same type*. In other words, your scary natural\ntransformations are just functions that change the functor _around_ a value\nwithout touching the value in the middle! Why is it a caterpillar, though?\nWell, when it becomes a butterfly, its outer shell changes a lot, but it's\nstill the same friendly personality inside üòå\n","title":"type (üêõ)","info":{"declType":"alias","alias":[["Data","NaturalTransformation"],{"Left":"NaturalTransformation"}],"fixity":{"associativity":"infixr","precedence":4}},"sourceSpan":{"start":[78,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[78,41]}},{"children":[],"comments":"Semigroups aren't too scary. We have a type that lets us \"smoosh\" values\ntogether and get a new value of that type. The `<>` operator is pretty good\nand intuitive, but let's use the \"high five\": two values coming together to\ncombine. `[2] üôè [3] == [2, 3]`, `\"He\" üôè \"llo\"` == \"Hello\", etc.\n","title":"(üôè)","info":{"declType":"alias","alias":[["Data","Semigroup"],{"Right":{"Left":{"Ident":"append"}}}],"fixity":{"associativity":"infixr","precedence":5}},"sourceSpan":{"start":[84,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[84,21]}},{"children":[],"comments":"The `<|>` operator gets a lot of publicity in parser libraries. When you go\nfor a rummage in the docs, you find phrases like \"monoidal applicative\",\nwhich don't help a lot. Basically, we're combining the behavior of two\nfunctor values of the same type. For some functors like `Array`, this is\njust the same as üôè. However, it's often for *fallbacks*: if your functor\nis a `Maybe`, `x <|> y <|> z <|> ...` will return the first `Just`, or\n`Nothing` if there aren't any.\n","title":"(üîó)","info":{"declType":"alias","alias":[["Control","Alt"],{"Right":{"Left":{"Ident":"alt"}}}],"fixity":{"associativity":"infixl","precedence":3}},"sourceSpan":{"start":[93,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[93,18]}},{"children":[],"comments":"Once in a while, we all need to debug. A lot of programmers from imperative\nlanguages find real trouble with debugging, as they can't just bung in a\n`console.log` to see values. *Well*, what if I told you... you *can*! So,\nwe can cheat a little bit, and use some escape hatches in the `Debug`\npackage, including `traceShow`, which will log anything `Show`able. With\nthis function, we can show a value at any point, and return anything!\n","title":"investigate","info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Data","Show"],"Show"],"constraintArgs":[{"tag":"TypeVar","contents":"a"}],"constraintData":null},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"b"}]}]}]},null]},null]}},"sourceSpan":{"start":[101,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[101,49]}},{"children":[],"comments":"For example, if we have `f x` and want to know what `x` is, we can write\n`x üîç f x`. This will return the same value as `f x`, but also print the\n`x` value (sneaky-like) to the console for us to look at.\n","title":"(üîç)","info":{"declType":"alias","alias":[["Prelewd"],{"Right":{"Left":{"Ident":"investigate"}}}],"fixity":{"associativity":"infixl","precedence":8}},"sourceSpan":{"start":[107,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[107,26]}},{"children":[],"comments":"Not only can we compose functions, but also functors! Maybe we want a list\nof `Maybe` values, or an `Aff` of a function. Whatever it is, we can write\nsome \"stacks\" with `Compose`.\n","title":"Compose","info":{"arguments":[["f",null],["g",null],["a",null]],"declType":"typeSynonym","type":{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"g"},{"tag":"TypeVar","contents":"a"}]}}]}},"sourceSpan":{"start":[112,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[112,29]}},{"children":[],"comments":"Before: `forall a b. Tuple a b -> Tuple a (Array b)`.\nAfter: `forall a. Tuple a üêõ Tuple a üçî Array`.\nI'm not saying that you should do this, but it looked funny to write out. A\nstack of functors is like a stack of burger ingredients: do as you will.\n","title":"type (üçî)","info":{"declType":"alias","alias":[["Prelewd"],{"Left":"Compose"}],"fixity":{"associativity":"infixr","precedence":9}},"sourceSpan":{"start":[118,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[118,27]}},{"children":[],"comments":"`Either` is defined as having two types. The constructors hold one each. So\nan `Either Int String` is *either* a `Left Int` or `Right String`. This has\nlots of uses, commonly with error-handling. You can use `Left` to carry any\nproblems, and `Right` to carry success. `Error üÜö Result`, if you like.\n","title":"type (üÜö)","info":{"declType":"alias","alias":[["Data","Either"],{"Left":"Either"}],"fixity":{"associativity":"infixl","precedence":3}},"sourceSpan":{"start":[124,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[124,26]}},{"children":[{"comments":null,"title":"Pair","info":{"arguments":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"a"}],"declType":"dataConstructor"},"sourceSpan":null}],"comments":"`Pair` holds two values of the same type. A *twin* of values, if you like.\n","title":"Pair","info":{"declType":"data","dataDeclType":"data","typeArguments":[["a",null]]},"sourceSpan":{"start":[127,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[127,23]}},{"children":[],"comments":"The most famous twin of all.\n","title":"(‚ôä)","info":{"declType":"alias","alias":[["Prelewd"],{"Right":{"Right":"Pair"}}],"fixity":{"associativity":"infixl","precedence":3}},"sourceSpan":{"start":[130,1],"name":"/Users/Tom/Git/purescript/premoji/src/Prelewd.purs","end":[130,18]}}]}],"resolvedDependencies":{"purescript-exceptions":"3.1.0","purescript-newtype":"2.0.0","purescript-control":"3.3.0","purescript-console":"3.0.0","purescript-either":"3.1.0","purescript-arrays":"4.1.2","purescript-maybe":"3.0.0","purescript-symbols":"3.0.0","purescript-type-equality":"2.1.0","purescript-distributive":"3.0.0","purescript-unfoldable":"3.0.0","purescript-invariant":"3.0.0","purescript-lazy":"3.0.0","purescript-monoid":"3.1.0","purescript-pairs":"5.0.0","purescript-foldable-traversable":"3.4.0","purescript-debug":"3.0.0","purescript-tailrec":"3.3.0","purescript-gen":"1.1.0","purescript-prelude":"3.1.0","purescript-st":"3.0.0","purescript-bifunctors":"3.0.0","purescript-nonempty":"4.0.0","purescript-unsafe-coerce":"3.0.0","purescript-integers":"3.1.0","purescript-eff":"3.1.0","purescript-transformers":"3.4.0","purescript-globals":"3.0.0","purescript-generics-rep":"5.2.0","purescript-math":"2.1.0","purescript-enums":"3.2.1","purescript-psci-support":"3.0.0","purescript-random":"3.0.0","purescript-tuples":"4.1.0","purescript-partial":"1.2.1","purescript-quickcheck":"4.4.0","purescript-strings":"3.3.1","purescript-identity":"3.1.0","purescript-lists":"4.9.0"},"version":"0.0.1","github":["i-am-tom","purescript-prelewd"],"versionTag":"v0.0.1","moduleMap":{"Data.BooleanAlgebra":"purescript-prelude","Data.Ring":"purescript-prelude","Control.Monad.Trans.Class":"purescript-transformers","Data.NonEmpty":"purescript-nonempty","Data.Pair":"purescript-pairs","Data.Char.Gen":"purescript-strings","Data.Traversable.Accum.Internal":"purescript-foldable-traversable","Data.Enum.Gen":"purescript-enums","Control.Comonad.Env":"purescript-transformers","Control.Comonad.Traced.Class":"purescript-transformers","Control.Monad.Eff.Unsafe":"purescript-eff","Data.Int.Bits":"purescript-integers","Data.Bifunctor.Flip":"purescript-bifunctors","Data.String.CodePoints":"purescript-strings","Data.Ord":"purescript-prelude","Control.Monad.Gen":"purescript-gen","Data.Monoid.Dual":"purescript-monoid","Control.Monad.Rec.Class":"purescript-tailrec","Data.Bitraversable":"purescript-foldable-traversable","Data.Boolean":"purescript-prelude","Control.Biapplicative":"purescript-bifunctors","Data.Array.ST.Iterator":"purescript-arrays","Data.Bounded":"purescript-prelude","Control.Monad.State.Trans":"purescript-transformers","Data.TraversableWithIndex":"purescript-foldable-traversable","Data.Int":"purescript-integers","Data.Show":"purescript-prelude","Data.Bifunctor.Clown":"purescript-bifunctors","Control.Monad.Writer.Trans":"purescript-transformers","Data.Foldable":"purescript-foldable-traversable","Control.Comonad.Store.Class":"purescript-transformers","Data.Enum":"purescript-enums","Control.Apply":"purescript-prelude","Data.Tuple.Nested":"purescript-tuples","Data.Generic.Rep.Semigroup":"purescript-generics-rep","Test.QuickCheck.LCG":"purescript-quickcheck","Control.Monad":"purescript-prelude","Data.Lazy":"purescript-lazy","Data.Monoid":"purescript-monoid","Control.Monad.Eff.Uncurried":"purescript-eff","Control.Monad.List.Trans":"purescript-transformers","Control.Monad.RWS":"purescript-transformers","Data.Maybe.First":"purescript-maybe","Control.Bind":"purescript-prelude","Data.Monoid.Additive":"purescript-monoid","Data.Symbol":"purescript-symbols","Data.String.Regex":"purescript-strings","Data.HeytingAlgebra":"purescript-prelude","Control.Alt":"purescript-control","Control.Monad.Maybe.Trans":"purescript-transformers","Control.Monad.Cont":"purescript-transformers","Data.List.ZipList":"purescript-lists","Data.Ord.Unsafe":"purescript-prelude","Data.Semigroup":"purescript-prelude","Control.Monad.Reader":"purescript-transformers","Data.Generic.Rep.Enum":"purescript-generics-rep","Data.Generic.Rep.Bounded":"purescript-generics-rep","Control.Monad.Eff":"purescript-eff","Control.Comonad.Traced.Trans":"purescript-transformers","Data.Array.ST.Partial":"purescript-arrays","Data.Generic.Rep.Show":"purescript-generics-rep","Data.Tuple":"purescript-tuples","Data.Semigroup.Foldable":"purescript-foldable-traversable","Control.Biapply":"purescript-bifunctors","Data.Distributive":"purescript-distributive","Type.Equality":"purescript-type-equality","Control.Alternative":"purescript-control","Data.Semiring":"purescript-prelude","Data.Traversable.Accum":"purescript-foldable-traversable","Data.CommutativeRing":"purescript-prelude","Data.NaturalTransformation":"purescript-prelude","Data.Monoid.Conj":"purescript-monoid","Data.Unfoldable":"purescript-unfoldable","Control.Monad.Eff.Random":"purescript-random","Control.Comonad.Store.Trans":"purescript-transformers","Control.Monad.ST":"purescript-st","Control.Monad.State.Class":"purescript-transformers","Data.List.Types":"purescript-lists","Data.Functor":"purescript-prelude","Unsafe.Coerce":"purescript-unsafe-coerce","Control.Monad.Writer.Class":"purescript-transformers","Data.Generic.Rep.Ord":"purescript-generics-rep","Control.Monad.Except":"purescript-transformers","Data.List.Lazy.Types":"purescript-lists","Control.Category":"purescript-prelude","Test.QuickCheck.Arbitrary":"purescript-quickcheck","Control.Monad.Gen.Common":"purescript-gen","Control.Monad.RWS.Trans":"purescript-transformers","Test.QuickCheck.Data.AlphaNumString":"purescript-quickcheck","Control.Monad.Cont.Trans":"purescript-transformers","Data.Maybe":"purescript-maybe","Data.String.Regex.Unsafe":"purescript-strings","Control.Comonad":"purescript-control","Data.Function":"purescript-prelude","Data.List":"purescript-lists","Data.Field":"purescript-prelude","Data.List.Lazy":"purescript-lists","Data.Generic.Rep.Eq":"purescript-generics-rep","Data.EuclideanRing":"purescript-prelude","Data.Functor.Invariant":"purescript-invariant","Control.Comonad.Traced":"purescript-transformers","Global.Unsafe":"purescript-globals","Data.String.Unsafe":"purescript-strings","Prelude":"purescript-prelude","Partial.Unsafe":"purescript-partial","Data.Array":"purescript-arrays","Data.Bifunctor.Product":"purescript-bifunctors","Control.Extend":"purescript-control","Control.Lazy":"purescript-control","Control.Monad.Reader.Trans":"purescript-transformers","Control.Comonad.Env.Class":"purescript-transformers","Data.Eq":"purescript-prelude","Data.Either.Nested":"purescript-either","Data.Newtype":"purescript-newtype","Control.Monad.Eff.Console":"purescript-console","Data.Semigroup.Traversable":"purescript-foldable-traversable","Data.Bifunctor":"purescript-bifunctors","Data.Monoid.Disj":"purescript-monoid","Control.Monad.Eff.Exception":"purescript-exceptions","Control.Monad.Gen.Class":"purescript-gen","Data.Array.Partial":"purescript-arrays","Data.String.CaseInsensitive":"purescript-strings","Control.MonadPlus":"purescript-control","Data.Void":"purescript-prelude","Control.MonadZero":"purescript-control","Control.Comonad.Store":"purescript-transformers","Control.Monad.Except.Trans":"purescript-transformers","Data.Bifunctor.Joker":"purescript-bifunctors","Data.FunctorWithIndex":"purescript-foldable-traversable","Data.DivisionRing":"purescript-prelude","Data.Bifunctor.Wrap":"purescript-bifunctors","PSCI.Support":"purescript-psci-support","Data.Maybe.Last":"purescript-maybe","Data.Unit":"purescript-prelude","Data.List.NonEmpty":"purescript-lists","Data.List.Lazy.NonEmpty":"purescript-lists","Data.Ordering":"purescript-prelude","Control.Monad.Cont.Class":"purescript-transformers","Data.Identity":"purescript-identity","Math":"purescript-math","Control.Comonad.Trans.Class":"purescript-transformers","Data.String":"purescript-strings","Control.Plus":"purescript-control","Control.Monad.Eff.Class":"purescript-eff","Test.QuickCheck":"purescript-quickcheck","Type.Row.Effect.Equality":"purescript-type-equality","Partial":"purescript-partial","Control.Comonad.Env.Trans":"purescript-transformers","Global":"purescript-globals","Control.Monad.Reader.Class":"purescript-transformers","Data.Monoid.Multiplicative":"purescript-monoid","Data.Array.ST":"purescript-arrays","Control.Monad.Error.Class":"purescript-transformers","Data.Generic.Rep.Monoid":"purescript-generics-rep","Control.Semigroupoid":"purescript-prelude","Debug.Trace":"purescript-debug","Data.Monoid.Alternate":"purescript-monoid","Data.Char":"purescript-strings","Data.Generic.Rep":"purescript-generics-rep","Data.Bifunctor.Join":"purescript-bifunctors","Control.Monad.Eff.Exception.Unsafe":"purescript-exceptions","Data.Bifoldable":"purescript-foldable-traversable","Data.Monoid.Endo":"purescript-monoid","Control.Monad.State":"purescript-transformers","Data.List.Partial":"purescript-lists","Data.String.Regex.Flags":"purescript-strings","Data.Either":"purescript-either","Control.Applicative":"purescript-prelude","Data.FoldableWithIndex":"purescript-foldable-traversable","Test.QuickCheck.Gen":"purescript-quickcheck","Control.Monad.Writer":"purescript-transformers","Data.Traversable":"purescript-foldable-traversable","Data.String.Gen":"purescript-strings"},"compilerVersion":"0.11.4"}