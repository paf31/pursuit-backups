{"uploader":"hdgarrood","packageMeta":{"homepage":"https://github.com/purescript/purescript-prelude","repository":{"url":"git://github.com/purescript/purescript-prelude.git","type":"git"},"ignore":["**/.*","bower_components","node_modules","output","test","bower.json","gulpfile.js","package.json"],"name":"purescript-prelude","keywords":["purescript"],"license":["MIT"],"description":"The PureScript Prelude"},"modules":[{"reExports":[],"name":"Prelude","comments":null,"declarations":[{"children":[{"comments":null,"title":"semigroupUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Semigroup"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[407,1],"name":"src/Prelude.purs","end":[410,1]}},{"comments":null,"title":"semiringUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Semiring"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[458,1],"name":"src/Prelude.purs","end":[464,1]}},{"comments":null,"title":"ringUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Ring"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[496,1],"name":"src/Prelude.purs","end":[499,1]}},{"comments":null,"title":"moduloSemiringUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"ModuloSemiring"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[531,1],"name":"src/Prelude.purs","end":[535,1]}},{"comments":null,"title":"divisionRingUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"DivisionRing"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[557,1],"name":"src/Prelude.purs","end":[565,1]}},{"comments":null,"title":"numUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Num"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[568,1],"name":"src/Prelude.purs","end":[577,1]}},{"comments":null,"title":"eqUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Eq"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[607,1],"name":"src/Prelude.purs","end":[610,1]}},{"comments":null,"title":"ordUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Ord"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[657,1],"name":"src/Prelude.purs","end":[660,1]}},{"comments":null,"title":"boundedUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Bounded"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[728,1],"name":"src/Prelude.purs","end":[732,1]}},{"comments":null,"title":"boundedOrdUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"BoundedOrd"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[763,1],"name":"src/Prelude.purs","end":[764,1]}},{"comments":null,"title":"booleanAlgebraUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"BooleanAlgebra"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[807,1],"name":"src/Prelude.purs","end":[812,1]}},{"comments":null,"title":"showUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Show"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[857,1],"name":"src/Prelude.purs","end":[860,1]}}],"comments":"The `Unit` type has a single inhabitant, called `unit`. It represents\nvalues with no computational content.\n\n`Unit` is often used, wrapped in a monadic type constructor, as the\nreturn type of a computation where only\nthe _effects_ are important.\n","title":"Unit","fixity":null,"info":{"declType":"data","dataDeclType":"newtype","typeArguments":[]},"sourceSpan":{"start":[36,1],"name":"src/Prelude.purs","end":[39,1]}},{"children":[],"comments":"`unit` is the sole inhabitant of the `Unit` type.\n","title":"unit","fixity":null,"info":{"declType":"value","type":{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}},"sourceSpan":{"start":[39,1],"name":"src/Prelude.purs","end":[40,1]}},{"children":[],"comments":"Applies a function to its argument.\n\n```purescript\nlength $ groupBy productCategory $ filter isInStock $ products\n```\n\nis equivalent to:\n\n```purescript\nlength (groupBy productCategory (filter isInStock products))\n```\n\n`($)` is different from [`(#)`](#-2) because it is right-infix instead of\nleft: `a $ b $ c $ d x = a $ (b $ (c $ (d $ x))) = a (b (c (d x)))`\n","title":"($)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[59,1],"name":"src/Prelude.purs","end":[60,1]}},{"children":[],"comments":"Applies an argument to a function.\n\n```purescript\nproducts # filter isInStock # groupBy productCategory # length\n```\n\nis equivalent to:\n\n```purescript\nlength (groupBy productCategory (filter isInStock products))\n```\n\n`(#)` is different from [`($)`](#-1) because it is left-infix instead of\nright: `x # a # b # c # d = (((x # a) # b) # c) # d = d (c (b (a x)))`\n","title":"(#)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]},{"tag":"TypeVar","contents":"b"}]}]},null]},null]}},"sourceSpan":{"start":[76,1],"name":"src/Prelude.purs","end":[77,1]}},{"children":[],"comments":"Flips the order of the arguments to a function of two arguments.\n\n```purescript\nflip const 1 2 = const 2 1 = 2\n```\n","title":"flip","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["c",{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"c"}]}]}}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"c"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[84,1],"name":"src/Prelude.purs","end":[85,1]}},{"children":[],"comments":"Returns its first argument and ignores its second.\n\n```purescript\nconst 1 \"hello\" = 1\n```\n","title":"const","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"a"}]}]},null]},null]}},"sourceSpan":{"start":[92,1],"name":"src/Prelude.purs","end":[93,1]}},{"children":[],"comments":"This function returns its first argument, and can be used to assert type\nequalities. This can be useful when types are otherwise ambiguous.\n\n```purescript\nmain = print $ [] `asTypeOf` [0]\n```\n\nIf instead, we had written `main = print []`, the type of the argument\n`[]` would have been ambiguous, resulting in a compile-time error.\n","title":"asTypeOf","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]},null]}},"sourceSpan":{"start":[104,1],"name":"src/Prelude.purs","end":[105,1]}},{"children":[],"comments":"An alias for `true`, which can be useful in guard clauses:\n\n```purescript\nmax x y | x >= y    = x\n        | otherwise = y\n```\n","title":"otherwise","fixity":null,"info":{"declType":"value","type":{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}},"sourceSpan":{"start":[113,1],"name":"src/Prelude.purs","end":[114,1]}},{"children":[{"comments":null,"title":"compose","info":{"declType":"typeClassMember","type":{"tag":"ForAll","contents":["d",{"tag":"ForAll","contents":["c",{"tag":"ForAll","contents":["b",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"c"}]},{"tag":"TypeVar","contents":"d"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"c"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"d"}]}]}]},null]},null]},null]}},"sourceSpan":null},{"comments":null,"title":"semigroupoidFn","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Semigroupoid"]},{"tag":"TypeConstructor","contents":[["Prim"],"Function"]}]}},"sourceSpan":{"start":[128,1],"name":"src/Prelude.purs","end":[131,1]}}],"comments":"A `Semigroupoid` is similar to a [`Category`](#category) but does not\nrequire an identity element `id`, just composable morphisms.\n\n`Semigroupoid`s must satisfy the following law:\n\n- Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`\n\nOne example of a `Semigroupoid` is the function type constructor `(->)`,\nwith `(<<<)` defined as function composition.\n","title":"Semigroupoid","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[125,1],"name":"src/Prelude.purs","end":[128,1]}},{"children":[],"comments":"`(<<<)` is an alias for `compose`.\n","title":"(<<<)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["d",{"tag":"ForAll","contents":["c",{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Semigroupoid"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"c"}]},{"tag":"TypeVar","contents":"d"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"c"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"d"}]}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[135,1],"name":"src/Prelude.purs","end":[136,1]}},{"children":[],"comments":"Forwards composition, or `(<<<)` with its arguments reversed.\n","title":"(>>>)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["d",{"tag":"ForAll","contents":["c",{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Semigroupoid"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"c"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"c"}]},{"tag":"TypeVar","contents":"d"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"d"}]}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[139,1],"name":"src/Prelude.purs","end":[140,1]}},{"children":[{"comments":null,"title":"id","info":{"declType":"typeClassMember","type":{"tag":"ForAll","contents":["t",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"a"},{"tag":"TypeVar","contents":"t"}]},{"tag":"TypeVar","contents":"t"}]},null]}},"sourceSpan":null},{"comments":null,"title":"categoryFn","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Category"]},{"tag":"TypeConstructor","contents":[["Prim"],"Function"]}]}},"sourceSpan":{"start":[153,1],"name":"src/Prelude.purs","end":[167,1]}}],"comments":"`Category`s consist of objects and composable morphisms between them, and\nas such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`\nmust have an identity element.\n\nInstances must satisfy the following law in addition to the\n`Semigroupoid` law:\n\n- Identity: `id <<< p = p <<< id = p`\n","title":"Category","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[[[["Prelude"],"Semigroupoid"],[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[150,1],"name":"src/Prelude.purs","end":[153,1]}},{"children":[{"comments":null,"title":"map","info":{"declType":"typeClassMember","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"b"}]}]}]},null]},null]}},"sourceSpan":null},{"comments":null,"title":"functorFn","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Functor"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"r"}]}}]}},"sourceSpan":{"start":[170,1],"name":"src/Prelude.purs","end":[173,1]}},{"comments":null,"title":"functorArray","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Functor"]},{"tag":"TypeConstructor","contents":[["Prim"],"Array"]}]}},"sourceSpan":{"start":[173,1],"name":"src/Prelude.purs","end":[176,1]}}],"comments":"A `Functor` is a type constructor which supports a mapping operation\n`(<$>)`.\n\n`(<$>)` can be used to turn functions `a -> b` into functions\n`f a -> f b` whose argument and return types use the type constructor `f`\nto represent some computational context.\n\nInstances must satisfy the following laws:\n\n- Identity: `(<$>) id = id`\n- Composition: `(<$>) (f <<< g) = (f <$>) <<< (g <$>)`\n","title":"Functor","fixity":null,"info":{"arguments":[["f",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[167,1],"name":"src/Prelude.purs","end":[170,1]}},{"children":[],"comments":"`(<$>)` is an alias for `map`\n","title":"(<$>)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["f",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Functor"],[{"tag":"TypeVar","contents":"f"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[182,1],"name":"src/Prelude.purs","end":[183,1]}},{"children":[],"comments":"`(<#>)` is `(<$>)` with its arguments reversed. For example:\n\n```purescript\n[1, 2, 3] <#> \\n -> n * n\n```\n","title":"(<#>)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["f",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Functor"],[{"tag":"TypeVar","contents":"f"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[190,1],"name":"src/Prelude.purs","end":[191,1]}},{"children":[],"comments":"The `void` function is used to ignore the type wrapped by a\n[`Functor`](#functor), replacing it with `Unit` and keeping only the type\ninformation provided by the type constructor itself.\n\n`void` is often useful when using `do` notation to change the return type\nof a monadic computation:\n\n```purescript\nmain = forE 1 10 \\n -> void do\n  print n\n  print (n * n)\n```\n","title":"void","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["f",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Functor"],[{"tag":"TypeVar","contents":"f"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}]}]},null]},null]}},"sourceSpan":{"start":[205,1],"name":"src/Prelude.purs","end":[206,1]}},{"children":[{"comments":null,"title":"apply","info":{"declType":"typeClassMember","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"b"}]}]}]},null]},null]}},"sourceSpan":null},{"comments":null,"title":"applyFn","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Apply"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"r"}]}}]}},"sourceSpan":{"start":[233,1],"name":"src/Prelude.purs","end":[236,1]}},{"comments":null,"title":"applyArray","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Apply"]},{"tag":"TypeConstructor","contents":[["Prim"],"Array"]}]}},"sourceSpan":{"start":[236,1],"name":"src/Prelude.purs","end":[239,1]}}],"comments":"The `Apply` class provides the `(<*>)` which is used to apply a function\nto an argument under a type constructor.\n\n`Apply` can be used to lift functions of two or more arguments to work on\nvalues wrapped with the type constructor `f`. It might also be understood\nin terms of the `lift2` function:\n\n```purescript\nlift2 :: forall f a b c. (Apply f) => (a -> b -> c) -> f a -> f b -> f c\nlift2 f a b = f <$> a <*> b\n```\n\n`(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts\nthe function application operator `($)` to arguments wrapped with the\ntype constructor `f`.\n\nInstances must satisfy the following law in addition to the `Functor`\nlaws:\n\n- Associative composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`\n\nFormally, `Apply` represents a strong lax semi-monoidal endofunctor.\n","title":"Apply","fixity":null,"info":{"arguments":[["f",null]],"declType":"typeClass","superclasses":[[[["Prelude"],"Functor"],[{"tag":"TypeVar","contents":"f"}]]]},"sourceSpan":{"start":[230,1],"name":"src/Prelude.purs","end":[233,1]}},{"children":[],"comments":"`(<*>)` is an alias for `apply`.\n","title":"(<*>)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["f",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Apply"],[{"tag":"TypeVar","contents":"f"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[242,1],"name":"src/Prelude.purs","end":[243,1]}},{"children":[{"comments":null,"title":"pure","info":{"declType":"typeClassMember","type":{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},null]}},"sourceSpan":null},{"comments":null,"title":"applicativeFn","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Applicative"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"r"}]}}]}},"sourceSpan":{"start":[266,1],"name":"src/Prelude.purs","end":[269,1]}},{"comments":null,"title":"applicativeArray","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Applicative"]},{"tag":"TypeConstructor","contents":[["Prim"],"Array"]}]}},"sourceSpan":{"start":[269,1],"name":"src/Prelude.purs","end":[273,1]}}],"comments":"The `Applicative` type class extends the [`Apply`](#apply) type class\nwith a `pure` function, which can be used to create values of type `f a`\nfrom values of type `a`.\n\nWhere [`Apply`](#apply) provides the ability to lift functions of two or\nmore arguments to functions whose arguments are wrapped using `f`, and\n[`Functor`](#functor) provides the ability to lift functions of one\nargument, `pure` can be seen as the function which lifts functions of\n_zero_ arguments. That is, `Applicative` functors support a lifting\noperation for any number of function arguments.\n\nInstances must satisfy the following laws in addition to the `Apply`\nlaws:\n\n- Identity: `(pure id) <*> v = v`\n- Composition: `(pure <<<) <*> f <*> g <*> h = f <*> (g <*> h)`\n- Homomorphism: `(pure f) <*> (pure x) = pure (f x)`\n- Interchange: `u <*> (pure y) = (pure ($ y)) <*> u`\n","title":"Applicative","fixity":null,"info":{"arguments":[["f",null]],"declType":"typeClass","superclasses":[[[["Prelude"],"Apply"],[{"tag":"TypeVar","contents":"f"}]]]},"sourceSpan":{"start":[263,1],"name":"src/Prelude.purs","end":[266,1]}},{"children":[],"comments":"`return` is an alias for `pure`.\n","title":"return","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Applicative"],[{"tag":"TypeVar","contents":"m"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"a"}]}]}]},null]},null]}},"sourceSpan":{"start":[273,1],"name":"src/Prelude.purs","end":[274,1]}},{"children":[],"comments":"`liftA1` provides a default implementation of `(<$>)` for any\n[`Applicative`](#applicative) functor, without using `(<$>)` as provided\nby the [`Functor`](#functor)-[`Applicative`](#applicative) superclass\nrelationship.\n\n`liftA1` can therefore be used to write [`Functor`](#functor) instances\nas follows:\n\n```purescript\ninstance functorF :: Functor F where\n  map = liftA1\n```\n","title":"liftA1","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["f",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Applicative"],[{"tag":"TypeVar","contents":"f"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"f"},{"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[288,1],"name":"src/Prelude.purs","end":[289,1]}},{"children":[{"comments":null,"title":"bind","info":{"declType":"typeClassMember","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"b"}]}]}}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"b"}]}]}]},null]},null]}},"sourceSpan":null},{"comments":null,"title":"bindFn","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Bind"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"r"}]}}]}},"sourceSpan":{"start":[320,1],"name":"src/Prelude.purs","end":[323,1]}},{"comments":null,"title":"bindArray","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Bind"]},{"tag":"TypeConstructor","contents":[["Prim"],"Array"]}]}},"sourceSpan":{"start":[323,1],"name":"src/Prelude.purs","end":[326,1]}}],"comments":"The `Bind` type class extends the [`Apply`](#apply) type class with a\n\"bind\" operation `(>>=)` which composes computations in sequence, using\nthe return value of one computation to determine the next computation.\n\nThe `>>=` operator can also be expressed using `do` notation, as follows:\n\n```purescript\nx >>= f = do y <- x\n             f y\n```\n\nwhere the function argument of `f` is given the name `y`.\n\nInstances must satisfy the following law in addition to the `Apply`\nlaws:\n\n- Associativity: `(x >>= f) >>= g = x >>= (\\k => f k >>= g)`\n\nAssociativity tells us that we can regroup operations which use `do`\nnotation so that we can unambiguously write, for example:\n\n```purescript\ndo x <- m1\n   y <- m2 x\n   m3 x y\n```\n","title":"Bind","fixity":null,"info":{"arguments":[["m",null]],"declType":"typeClass","superclasses":[[[["Prelude"],"Apply"],[{"tag":"TypeVar","contents":"m"}]]]},"sourceSpan":{"start":[317,1],"name":"src/Prelude.purs","end":[320,1]}},{"children":[],"comments":"`(>>=)` is an alias for `bind`.\n","title":"(>>=)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Bind"],[{"tag":"TypeVar","contents":"m"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"b"}]}]}}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[331,1],"name":"src/Prelude.purs","end":[332,1]}},{"children":[{"comments":null,"title":"monadFn","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Monad"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"r"}]}}]}},"sourceSpan":{"start":[346,1],"name":"src/Prelude.purs","end":[347,1]}},{"comments":null,"title":"monadArray","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Monad"]},{"tag":"TypeConstructor","contents":[["Prim"],"Array"]}]}},"sourceSpan":{"start":[347,1],"name":"src/Prelude.purs","end":[360,1]}}],"comments":"The `Monad` type class combines the operations of the `Bind` and\n`Applicative` type classes. Therefore, `Monad` instances represent type\nconstructors which support sequential composition, and also lifting of\nfunctions of arbitrary arity.\n\nInstances must satisfy the following laws in addition to the\n`Applicative` and `Bind` laws:\n\n- Left Identity: `pure x >>= f = f x`\n- Right Identity: `x >>= pure = x`\n","title":"Monad","fixity":null,"info":{"arguments":[["m",null]],"declType":"typeClass","superclasses":[[[["Prelude"],"Applicative"],[{"tag":"TypeVar","contents":"m"}]],[[["Prelude"],"Bind"],[{"tag":"TypeVar","contents":"m"}]]]},"sourceSpan":{"start":[344,1],"name":"src/Prelude.purs","end":[346,1]}},{"children":[],"comments":"`liftM1` provides a default implementation of `(<$>)` for any\n[`Monad`](#monad), without using `(<$>)` as provided by the\n[`Functor`](#functor)-[`Monad`](#monad) superclass relationship.\n\n`liftM1` can therefore be used to write [`Functor`](#functor) instances\nas follows:\n\n```purescript\ninstance functorF :: Functor F where\n  map = liftM1\n```\n","title":"liftM1","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Monad"],[{"tag":"TypeVar","contents":"m"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[360,1],"name":"src/Prelude.purs","end":[361,1]}},{"children":[],"comments":"`ap` provides a default implementation of `(<*>)` for any\n[`Monad`](#monad), without using `(<*>)` as provided by the\n[`Apply`](#apply)-[`Monad`](#monad) superclass relationship.\n\n`ap` can therefore be used to write [`Apply`](#apply) instances as\nfollows:\n\n```purescript\ninstance applyF :: Apply F where\n  apply = ap\n```\n","title":"ap","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Monad"],[{"tag":"TypeVar","contents":"m"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"m"},{"tag":"TypeVar","contents":"b"}]}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[376,1],"name":"src/Prelude.purs","end":[377,1]}},{"children":[{"comments":null,"title":"append","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"semigroupString","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Semigroup"]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}},"sourceSpan":{"start":[404,1],"name":"src/Prelude.purs","end":[407,1]}},{"comments":null,"title":"semigroupUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Semigroup"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[407,1],"name":"src/Prelude.purs","end":[410,1]}},{"comments":null,"title":"semigroupFn","info":{"declType":"instance","dependencies":[[[["Prelude"],"Semigroup"],[{"tag":"TypeVar","contents":"s'"}]]],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Semigroup"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"s'"}]}}]}},"sourceSpan":{"start":[410,1],"name":"src/Prelude.purs","end":[413,1]}},{"comments":null,"title":"semigroupOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Semigroup"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Ordering"]}]}},"sourceSpan":{"start":[413,1],"name":"src/Prelude.purs","end":[418,1]}},{"comments":null,"title":"semigroupArray","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Semigroup"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"tag":"TypeVar","contents":"a"}]}}]}},"sourceSpan":{"start":[418,1],"name":"src/Prelude.purs","end":[421,1]}}],"comments":"The `Semigroup` type class identifies an associative operation on a type.\n\nInstances are required to satisfy the following law:\n\n- Associativity: `(x <> y) <> z = x <> (y <> z)`\n\nOne example of a `Semigroup` is `String`, with `(<>)` defined as string\nconcatenation.\n","title":"Semigroup","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[390,1],"name":"src/Prelude.purs","end":[393,1]}},{"children":[],"comments":"`(<>)` is an alias for `append`.\n","title":"(<>)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["s",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Semigroup"],[{"tag":"TypeVar","contents":"s"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"s"}]}]}]},null]}},"sourceSpan":{"start":[397,1],"name":"src/Prelude.purs","end":[398,1]}},{"children":[],"comments":"`(++)` is an alternative alias for `append`.\n","title":"(++)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["s",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Semigroup"],[{"tag":"TypeVar","contents":"s"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"s"}]}]}]},null]}},"sourceSpan":{"start":[401,1],"name":"src/Prelude.purs","end":[402,1]}},{"children":[{"comments":null,"title":"add","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"zero","info":{"declType":"typeClassMember","type":{"tag":"TypeVar","contents":"a"}},"sourceSpan":null},{"comments":null,"title":"mul","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"one","info":{"declType":"typeClassMember","type":{"tag":"TypeVar","contents":"a"}},"sourceSpan":null},{"comments":null,"title":"semiringInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Semiring"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[446,1],"name":"src/Prelude.purs","end":[452,1]}},{"comments":null,"title":"semiringNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Semiring"]},{"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]}},"sourceSpan":{"start":[452,1],"name":"src/Prelude.purs","end":[458,1]}},{"comments":null,"title":"semiringUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Semiring"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[458,1],"name":"src/Prelude.purs","end":[464,1]}}],"comments":"The `Semiring` class is for types that support an addition and\nmultiplication operation.\n\nInstances must satisfy the following laws:\n\n- Commutative monoid under addition:\n  - Associativity: `(a + b) + c = a + (b + c)`\n  - Identity: `zero + a = a + zero = a`\n  - Commutative: `a + b = b + a`\n- Monoid under multiplication:\n  - Associativity: `(a * b) * c = a * (b * c)`\n  - Identity: `one * a = a * one = a`\n- Multiplication distributes over addition:\n  - Left distributivity: `a * (b + c) = (a * b) + (a * c)`\n  - Right distributivity: `(a + b) * c = (a * c) + (b * c)`\n- Annihiliation: `zero * a = a * zero = zero`\n","title":"Semiring","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[440,1],"name":"src/Prelude.purs","end":[446,1]}},{"children":[],"comments":"`(+)` is an alias for `add`.\n","title":"(+)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Semiring"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}]},null]}},"sourceSpan":{"start":[468,1],"name":"src/Prelude.purs","end":[469,1]}},{"children":[],"comments":"`(*)` is an alias for `mul`.\n","title":"(*)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Semiring"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}]},null]}},"sourceSpan":{"start":[472,1],"name":"src/Prelude.purs","end":[473,1]}},{"children":[{"comments":null,"title":"sub","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"ringInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Ring"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[490,1],"name":"src/Prelude.purs","end":[493,1]}},{"comments":null,"title":"ringNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Ring"]},{"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]}},"sourceSpan":{"start":[493,1],"name":"src/Prelude.purs","end":[496,1]}},{"comments":null,"title":"ringUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Ring"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[496,1],"name":"src/Prelude.purs","end":[499,1]}}],"comments":"The `Ring` class is for types that support addition, multiplication,\nand subtraction operations.\n\nInstances must satisfy the following law in addition to the `Semiring`\nlaws:\n\n- Additive inverse: `a - a = (zero - a) + a = zero`\n","title":"Ring","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[[[["Prelude"],"Semiring"],[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[487,1],"name":"src/Prelude.purs","end":[490,1]}},{"children":[],"comments":"`(-)` is an alias for `sub`.\n","title":"(-)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Ring"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}]},null]}},"sourceSpan":{"start":[502,1],"name":"src/Prelude.purs","end":[503,1]}},{"children":[],"comments":"`negate x` can be used as a shorthand for `zero - x`.\n","title":"negate","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Ring"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]},null]}},"sourceSpan":{"start":[506,1],"name":"src/Prelude.purs","end":[507,1]}},{"children":[{"comments":null,"title":"div","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"mod","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"moduloSemiringInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"ModuloSemiring"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[523,1],"name":"src/Prelude.purs","end":[527,1]}},{"comments":null,"title":"moduloSemiringNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"ModuloSemiring"]},{"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]}},"sourceSpan":{"start":[527,1],"name":"src/Prelude.purs","end":[531,1]}},{"comments":null,"title":"moduloSemiringUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"ModuloSemiring"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[531,1],"name":"src/Prelude.purs","end":[535,1]}}],"comments":"The `ModuloSemiring` class is for types that support addition,\nmultiplication, division, and modulo (division remainder) operations.\n\nInstances must satisfy the following law in addition to the `Semiring`\nlaws:\n\n- Remainder: ``a / b * b + (a `mod` b) = a``\n","title":"ModuloSemiring","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[[[["Prelude"],"Semiring"],[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[519,1],"name":"src/Prelude.purs","end":[523,1]}},{"children":[],"comments":"`(/)` is an alias for `div`.\n","title":"(/)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"ModuloSemiring"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}]},null]}},"sourceSpan":{"start":[538,1],"name":"src/Prelude.purs","end":[539,1]}},{"children":[{"comments":null,"title":"divisionRingNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"DivisionRing"]},{"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]}},"sourceSpan":{"start":[556,1],"name":"src/Prelude.purs","end":[557,1]}},{"comments":null,"title":"divisionRingUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"DivisionRing"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[557,1],"name":"src/Prelude.purs","end":[565,1]}}],"comments":"A `Ring` where every nonzero element has a multiplicative inverse.\n\nInstances must satisfy the following law in addition to the `Ring` and\n`ModuloSemiring` laws:\n\n- Multiplicative inverse: `(one / x) * x = one`\n\nAs a consequence of this ```a `mod` b = zero``` as no divide operation\nwill have a remainder.\n","title":"DivisionRing","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[[[["Prelude"],"Ring"],[{"tag":"TypeVar","contents":"a"}]],[[["Prelude"],"ModuloSemiring"],[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[554,1],"name":"src/Prelude.purs","end":[556,1]}},{"children":[{"comments":null,"title":"numNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Num"]},{"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]}},"sourceSpan":{"start":[567,1],"name":"src/Prelude.purs","end":[568,1]}},{"comments":null,"title":"numUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Num"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[568,1],"name":"src/Prelude.purs","end":[577,1]}}],"comments":"The `Num` class is for types that are commutative fields.\n\nInstances must satisfy the following law in addition to the\n`DivisionRing` laws:\n\n- Commutative multiplication: `a * b = b * a`\n","title":"Num","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[[[["Prelude"],"DivisionRing"],[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[565,1],"name":"src/Prelude.purs","end":[567,1]}},{"children":[{"comments":null,"title":"eq","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}]}},"sourceSpan":null},{"comments":null,"title":"eqBoolean","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Eq"]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}},"sourceSpan":{"start":[592,1],"name":"src/Prelude.purs","end":[595,1]}},{"comments":null,"title":"eqInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Eq"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[595,1],"name":"src/Prelude.purs","end":[598,1]}},{"comments":null,"title":"eqNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Eq"]},{"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]}},"sourceSpan":{"start":[598,1],"name":"src/Prelude.purs","end":[601,1]}},{"comments":null,"title":"eqChar","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Eq"]},{"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}},"sourceSpan":{"start":[601,1],"name":"src/Prelude.purs","end":[604,1]}},{"comments":null,"title":"eqString","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Eq"]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}},"sourceSpan":{"start":[604,1],"name":"src/Prelude.purs","end":[607,1]}},{"comments":null,"title":"eqUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Eq"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[607,1],"name":"src/Prelude.purs","end":[610,1]}},{"comments":null,"title":"eqArray","info":{"declType":"instance","dependencies":[[[["Prelude"],"Eq"],[{"tag":"TypeVar","contents":"a"}]]],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Eq"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"tag":"TypeVar","contents":"a"}]}}]}},"sourceSpan":{"start":[610,1],"name":"src/Prelude.purs","end":[613,1]}},{"comments":null,"title":"eqOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Eq"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Ordering"]}]}},"sourceSpan":{"start":[613,1],"name":"src/Prelude.purs","end":[619,1]}}],"comments":"The `Eq` type class represents types which support decidable equality.\n\n`Eq` instances should satisfy the following laws:\n\n- Reflexivity: `x == x = true`\n- Symmetry: `x == y = y == x`\n- Transitivity: if `x == y` and `y == z` then `x == z`\n","title":"Eq","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[577,1],"name":"src/Prelude.purs","end":[580,1]}},{"children":[],"comments":"`(==)` is an alias for `eq`. Tests whether one value is equal to another.\n","title":"(==)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Eq"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}]}]},null]}},"sourceSpan":{"start":[584,1],"name":"src/Prelude.purs","end":[585,1]}},{"children":[],"comments":"`(/=)` tests whether one value is _not equal_ to another. Shorthand for\n`not (x == y)`.\n","title":"(/=)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Eq"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}]}]},null]}},"sourceSpan":{"start":[589,1],"name":"src/Prelude.purs","end":[590,1]}},{"children":[{"comments":null,"title":"LT","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"GT","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"EQ","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"semigroupOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Semigroup"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Ordering"]}]}},"sourceSpan":{"start":[413,1],"name":"src/Prelude.purs","end":[418,1]}},{"comments":null,"title":"eqOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Eq"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Ordering"]}]}},"sourceSpan":{"start":[613,1],"name":"src/Prelude.purs","end":[619,1]}},{"comments":null,"title":"ordOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Ord"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Ordering"]}]}},"sourceSpan":{"start":[668,1],"name":"src/Prelude.purs","end":[677,1]}},{"comments":null,"title":"boundedOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Bounded"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Ordering"]}]}},"sourceSpan":{"start":[732,1],"name":"src/Prelude.purs","end":[736,1]}},{"comments":null,"title":"boundedOrdOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"BoundedOrd"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Ordering"]}]}},"sourceSpan":{"start":[764,1],"name":"src/Prelude.purs","end":[765,1]}},{"comments":null,"title":"showOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Show"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Ordering"]}]}},"sourceSpan":{"start":[863,1],"name":"src/Prelude.purs","end":[868,1]}}],"comments":"The `Ordering` data type represents the three possible outcomes of\ncomparing two values:\n\n`LT` - The first value is _less than_ the second.\n`GT` - The first value is _greater than_ the second.\n`EQ` - The first value is _equal to_ the second.\n","title":"Ordering","fixity":null,"info":{"declType":"data","dataDeclType":"data","typeArguments":[]},"sourceSpan":{"start":[629,1],"name":"src/Prelude.purs","end":[639,1]}},{"children":[{"comments":null,"title":"compare","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":[["Prelude"],"Ordering"]}]}]}},"sourceSpan":null},{"comments":null,"title":"ordBoolean","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Ord"]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}},"sourceSpan":{"start":[642,1],"name":"src/Prelude.purs","end":[645,1]}},{"comments":null,"title":"ordInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Ord"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[645,1],"name":"src/Prelude.purs","end":[648,1]}},{"comments":null,"title":"ordNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Ord"]},{"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]}},"sourceSpan":{"start":[648,1],"name":"src/Prelude.purs","end":[651,1]}},{"comments":null,"title":"ordString","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Ord"]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}},"sourceSpan":{"start":[651,1],"name":"src/Prelude.purs","end":[654,1]}},{"comments":null,"title":"ordChar","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Ord"]},{"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}},"sourceSpan":{"start":[654,1],"name":"src/Prelude.purs","end":[657,1]}},{"comments":null,"title":"ordUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Ord"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[657,1],"name":"src/Prelude.purs","end":[660,1]}},{"comments":null,"title":"ordArray","info":{"declType":"instance","dependencies":[[[["Prelude"],"Ord"],[{"tag":"TypeVar","contents":"a"}]]],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Ord"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"tag":"TypeVar","contents":"a"}]}}]}},"sourceSpan":{"start":[660,1],"name":"src/Prelude.purs","end":[666,1]}},{"comments":null,"title":"ordOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Ord"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Ordering"]}]}},"sourceSpan":{"start":[668,1],"name":"src/Prelude.purs","end":[677,1]}}],"comments":"The `Ord` type class represents types which support comparisons with a\n_total order_.\n\n`Ord` instances should satisfy the laws of total orderings:\n\n- Reflexivity: `a <= a`\n- Antisymmetry: if `a <= b` and `b <= a` then `a = b`\n- Transitivity: if `a <= b` and `b <= c` then `a <= c`\n","title":"Ord","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[[[["Prelude"],"Eq"],[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[639,1],"name":"src/Prelude.purs","end":[642,1]}},{"children":[],"comments":"Test whether one value is _strictly less than_ another.\n","title":"(<)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Ord"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}]}]},null]}},"sourceSpan":{"start":[683,1],"name":"src/Prelude.purs","end":[684,1]}},{"children":[],"comments":"Test whether one value is _strictly greater than_ another.\n","title":"(>)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Ord"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}]}]},null]}},"sourceSpan":{"start":[689,1],"name":"src/Prelude.purs","end":[690,1]}},{"children":[],"comments":"Test whether one value is _non-strictly less than_ another.\n","title":"(<=)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Ord"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}]}]},null]}},"sourceSpan":{"start":[695,1],"name":"src/Prelude.purs","end":[696,1]}},{"children":[],"comments":"Test whether one value is _non-strictly greater than_ another.\n","title":"(>=)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"Ord"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}]}]},null]}},"sourceSpan":{"start":[701,1],"name":"src/Prelude.purs","end":[702,1]}},{"children":[],"comments":null,"title":"unsafeCompare","fixity":null,"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":[["Prelude"],"Ordering"]}]}]},null]}},"sourceSpan":{"start":[706,1],"name":"src/Prelude.purs","end":[707,1]}},{"children":[{"comments":null,"title":"top","info":{"declType":"typeClassMember","type":{"tag":"TypeVar","contents":"a"}},"sourceSpan":null},{"comments":null,"title":"bottom","info":{"declType":"typeClassMember","type":{"tag":"TypeVar","contents":"a"}},"sourceSpan":null},{"comments":null,"title":"boundedBoolean","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Bounded"]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}},"sourceSpan":{"start":[724,1],"name":"src/Prelude.purs","end":[728,1]}},{"comments":null,"title":"boundedUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Bounded"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[728,1],"name":"src/Prelude.purs","end":[732,1]}},{"comments":null,"title":"boundedOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Bounded"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Ordering"]}]}},"sourceSpan":{"start":[732,1],"name":"src/Prelude.purs","end":[736,1]}},{"comments":null,"title":"boundedInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Bounded"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[736,1],"name":"src/Prelude.purs","end":[741,1]}},{"comments":"Characters fall within the Unicode range.\n","title":"boundedChar","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Bounded"]},{"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}},"sourceSpan":{"start":[741,1],"name":"src/Prelude.purs","end":[745,1]}},{"comments":null,"title":"boundedFn","info":{"declType":"instance","dependencies":[[[["Prelude"],"Bounded"],[{"tag":"TypeVar","contents":"b"}]]],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Bounded"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]}},"sourceSpan":{"start":[745,1],"name":"src/Prelude.purs","end":[749,1]}}],"comments":"The `Bounded` type class represents types that are finite.\n\nAlthough there are no \"internal\" laws for `Bounded`, every value of `a`\nshould be considered less than or equal to `top` by some means, and greater\nthan or equal to `bottom`.\n\nThe lack of explicit `Ord` constraint allows flexibility in the use of\n`Bounded` so it can apply to total and partially ordered sets, boolean\nalgebras, etc.\n","title":"Bounded","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[720,1],"name":"src/Prelude.purs","end":[724,1]}},{"children":[{"comments":null,"title":"boundedOrdBoolean","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"BoundedOrd"]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}},"sourceSpan":{"start":[762,1],"name":"src/Prelude.purs","end":[763,1]}},{"comments":null,"title":"boundedOrdUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"BoundedOrd"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[763,1],"name":"src/Prelude.purs","end":[764,1]}},{"comments":null,"title":"boundedOrdOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"BoundedOrd"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Ordering"]}]}},"sourceSpan":{"start":[764,1],"name":"src/Prelude.purs","end":[765,1]}},{"comments":null,"title":"boundedOrdInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"BoundedOrd"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[765,1],"name":"src/Prelude.purs","end":[766,1]}},{"comments":null,"title":"boundedOrdChar","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"BoundedOrd"]},{"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}},"sourceSpan":{"start":[766,1],"name":"src/Prelude.purs","end":[797,1]}}],"comments":"The `BoundedOrd` type class represents totally ordered finite data types.\n\nInstances should satisfy the following law in addition to the `Ord` laws:\n\n- Ordering: `bottom <= a <= top`\n","title":"BoundedOrd","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[[[["Prelude"],"Bounded"],[{"tag":"TypeVar","contents":"a"}]],[[["Prelude"],"Ord"],[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[760,1],"name":"src/Prelude.purs","end":[762,1]}},{"children":[{"comments":null,"title":"conj","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"disj","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}},"sourceSpan":null},{"comments":null,"title":"not","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}},"sourceSpan":null},{"comments":null,"title":"booleanAlgebraBoolean","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"BooleanAlgebra"]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}},"sourceSpan":{"start":[802,1],"name":"src/Prelude.purs","end":[807,1]}},{"comments":null,"title":"booleanAlgebraUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"BooleanAlgebra"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[807,1],"name":"src/Prelude.purs","end":[812,1]}},{"comments":null,"title":"booleanAlgebraFn","info":{"declType":"instance","dependencies":[[[["Prelude"],"BooleanAlgebra"],[{"tag":"TypeVar","contents":"b"}]]],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"BooleanAlgebra"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]}},"sourceSpan":{"start":[812,1],"name":"src/Prelude.purs","end":[817,1]}}],"comments":"The `BooleanAlgebra` type class represents types that behave like boolean\nvalues.\n\nInstances should satisfy the following laws in addition to the `Bounded`\nlaws:\n\n- Associativity:\n  - `a || (b || c) = (a || b) || c`\n  - `a && (b && c) = (a && b) && c`\n- Commutativity:\n  - `a || b = b || a`\n  - `a && b = b && a`\n- Distributivity:\n  - `a && (b || c) = (a && b) || (a && c)`\n  - `a || (b && c) = (a || b) && (a || c)`\n- Identity:\n  - `a || bottom = a`\n  - `a && top = a`\n- Idempotent:\n  - `a || a = a`\n  - `a && a = a`\n- Absorption:\n  - `a || (a && b) = a`\n  - `a && (a || b) = a`\n- Annhiliation:\n  - `a || top = top`\n- Complementation:\n  - `a && not a = bottom`\n  - `a || not a = top`\n","title":"BooleanAlgebra","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[[[["Prelude"],"Bounded"],[{"tag":"TypeVar","contents":"a"}]]]},"sourceSpan":{"start":[797,1],"name":"src/Prelude.purs","end":[802,1]}},{"children":[],"comments":"`(&&)` is an alias for `conj`.\n","title":"(&&)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"BooleanAlgebra"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}]},null]}},"sourceSpan":{"start":[821,1],"name":"src/Prelude.purs","end":[822,1]}},{"children":[],"comments":"`(||)` is an alias for `disj`.\n","title":"(||)","fixity":{"associativity":"infixl","precedence":-1},"info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[[[[["Prelude"],"BooleanAlgebra"],[{"tag":"TypeVar","contents":"a"}]]],{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"a"}]}]}]},null]}},"sourceSpan":{"start":[825,1],"name":"src/Prelude.purs","end":[826,1]}},{"children":[{"comments":null,"title":"show","info":{"declType":"typeClassMember","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}},"sourceSpan":null},{"comments":null,"title":"showBoolean","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Show"]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}},"sourceSpan":{"start":[841,1],"name":"src/Prelude.purs","end":[845,1]}},{"comments":null,"title":"showInt","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Show"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[845,1],"name":"src/Prelude.purs","end":[848,1]}},{"comments":null,"title":"showNumber","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Show"]},{"tag":"TypeConstructor","contents":[["Prim"],"Number"]}]}},"sourceSpan":{"start":[848,1],"name":"src/Prelude.purs","end":[851,1]}},{"comments":null,"title":"showChar","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Show"]},{"tag":"TypeConstructor","contents":[["Prim"],"Char"]}]}},"sourceSpan":{"start":[851,1],"name":"src/Prelude.purs","end":[854,1]}},{"comments":null,"title":"showString","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Show"]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}},"sourceSpan":{"start":[854,1],"name":"src/Prelude.purs","end":[857,1]}},{"comments":null,"title":"showUnit","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Show"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Unit"]}]}},"sourceSpan":{"start":[857,1],"name":"src/Prelude.purs","end":[860,1]}},{"comments":null,"title":"showArray","info":{"declType":"instance","dependencies":[[[["Prelude"],"Show"],[{"tag":"TypeVar","contents":"a"}]]],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Show"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"tag":"TypeVar","contents":"a"}]}}]}},"sourceSpan":{"start":[860,1],"name":"src/Prelude.purs","end":[863,1]}},{"comments":null,"title":"showOrdering","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prelude"],"Show"]},{"tag":"TypeConstructor","contents":[["Prelude"],"Ordering"]}]}},"sourceSpan":{"start":[863,1],"name":"src/Prelude.purs","end":[868,1]}}],"comments":"The `Show` type class represents those types which can be converted into\na human-readable `String` representation.\n\nWhile not required, it is recommended that for any expression `x`, the\nstring `show x` be executable PureScript code which evaluates to the same\nvalue as the expression `x`.\n","title":"Show","fixity":null,"info":{"arguments":[["a",null]],"declType":"typeClass","superclasses":[]},"sourceSpan":{"start":[838,1],"name":"src/Prelude.purs","end":[841,1]}}]}],"resolvedDependencies":{},"bookmarks":[{"package":null,"item":["Prelude","Unit"]},{"package":null,"item":["Prelude","unit"]},{"package":null,"item":["Prelude","($)"]},{"package":null,"item":["Prelude","(#)"]},{"package":null,"item":["Prelude","flip"]},{"package":null,"item":["Prelude","const"]},{"package":null,"item":["Prelude","asTypeOf"]},{"package":null,"item":["Prelude","otherwise"]},{"package":null,"item":["Prelude","Semigroupoid"]},{"package":null,"item":["Prelude","(<<<)"]},{"package":null,"item":["Prelude","(>>>)"]},{"package":null,"item":["Prelude","Category"]},{"package":null,"item":["Prelude","Functor"]},{"package":null,"item":["Prelude","(<$>)"]},{"package":null,"item":["Prelude","(<#>)"]},{"package":null,"item":["Prelude","void"]},{"package":null,"item":["Prelude","Apply"]},{"package":null,"item":["Prelude","(<*>)"]},{"package":null,"item":["Prelude","Applicative"]},{"package":null,"item":["Prelude","return"]},{"package":null,"item":["Prelude","liftA1"]},{"package":null,"item":["Prelude","Bind"]},{"package":null,"item":["Prelude","(>>=)"]},{"package":null,"item":["Prelude","Monad"]},{"package":null,"item":["Prelude","liftM1"]},{"package":null,"item":["Prelude","ap"]},{"package":null,"item":["Prelude","Semigroup"]},{"package":null,"item":["Prelude","(<>)"]},{"package":null,"item":["Prelude","(++)"]},{"package":null,"item":["Prelude","Semiring"]},{"package":null,"item":["Prelude","(+)"]},{"package":null,"item":["Prelude","(*)"]},{"package":null,"item":["Prelude","Ring"]},{"package":null,"item":["Prelude","(-)"]},{"package":null,"item":["Prelude","negate"]},{"package":null,"item":["Prelude","ModuloSemiring"]},{"package":null,"item":["Prelude","(/)"]},{"package":null,"item":["Prelude","DivisionRing"]},{"package":null,"item":["Prelude","Num"]},{"package":null,"item":["Prelude","Eq"]},{"package":null,"item":["Prelude","(==)"]},{"package":null,"item":["Prelude","(/=)"]},{"package":null,"item":["Prelude","Ordering"]},{"package":null,"item":["Prelude","Ord"]},{"package":null,"item":["Prelude","(<)"]},{"package":null,"item":["Prelude","(>)"]},{"package":null,"item":["Prelude","(<=)"]},{"package":null,"item":["Prelude","(>=)"]},{"package":null,"item":["Prelude","unsafeCompare"]},{"package":null,"item":["Prelude","Bounded"]},{"package":null,"item":["Prelude","BoundedOrd"]},{"package":null,"item":["Prelude","BooleanAlgebra"]},{"package":null,"item":["Prelude","(&&)"]},{"package":null,"item":["Prelude","(||)"]},{"package":null,"item":["Prelude","Show"]}],"version":"0.1.4","github":["purescript","purescript-prelude"],"versionTag":"v0.1.4","compilerVersion":"0.8.5.0"}