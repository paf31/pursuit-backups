{"uploader":"paf31","packageMeta":{"homepage":"https://github.com/purescript/purescript-proxy","repository":{"url":"git://github.com/purescript/purescript-proxy.git","type":"git"},"ignore":["**/.*","bower_components","node_modules","output","test","bower.json","package.json"],"name":"purescript-proxy","license":["MIT"],"description":"Value proxy for type inputs"},"tagTime":"2017-03-26T01:07:06+0000","modules":[{"reExports":[],"name":"Type.Proxy","comments":"The `Proxy` type and values are for situations where type information is\nrequired for an input to determine the type of an output, but where it is\nnot possible or convenient to provide a _value_ for the input.\n\nA hypothetical example: if you have a class that is used to handle the\nresult of an AJAX request, you may want to use this information to set the\nexpected content type of the request, so you might have a class something\nlike this:\n\n``` purescript\nclass AjaxResponse a where\n  responseType :: a -> ResponseType\n  fromResponse :: Foreign -> a\n```\n\nThe problem here is `responseType` requires a value of type `a`, but we\nwon't have a value of that type until the request has been completed. The\nsolution is to use a `Proxy` type instead:\n\n``` purescript\nclass AjaxResponse a where\n  responseType :: Proxy a -> ResponseType\n  fromResponse :: Foreign -> a\n```\n\nWe can now call `responseType (Proxy :: Proxy SomeContentType)` to produce\na `ResponseType` for `SomeContentType` without having to construct some\nempty version of `SomeContentType` first. In situations like this where\nthe `Proxy` type can be statically determined, it is recommended to pull\nout the definition to the top level and make a declaration like:\n\n``` purescript\n_SomeContentType :: Proxy SomeContentType\n_SomeContentType = Proxy\n```\n\nThat way the proxy value can be used as `responseType _SomeContentType`\nfor improved readability. However, this is not always possible, sometimes\nthe type required will be determined by a type variable. As PureScript has\nscoped type variables, we can do things like this:\n\n``` purescript\nmakeRequest :: URL -> ResponseType -> Aff _ Foreign\nmakeRequest = ...\n\nfetchData :: forall a. (AjaxResponse a) => URL -> Aff _ a\nfetchData url = fromResponse <$> makeRequest url (responseType (Proxy :: Proxy a))\n```\n","declarations":[{"children":[{"comments":null,"title":"Proxy","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null}],"comments":"Value proxy for kind `Type` types.\n","title":"Proxy","info":{"declType":"data","dataDeclType":"data","typeArguments":[["a",null]]},"sourceSpan":{"start":[52,1],"name":"/private/tmp/pursuit-staging/.psc-package/psc-0.11.3/proxy/v2.0.0/src/Type/Proxy.purs","end":[52,21]}},{"children":[{"comments":null,"title":"Proxy2","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null}],"comments":"Value proxy for kind `Type -> Type` types.\n","title":"Proxy2","info":{"declType":"data","dataDeclType":"data","typeArguments":[["a",{"tag":"FunKind","contents":[{"tag":"NamedKind","contents":[["Prim"],"Type"]},{"tag":"NamedKind","contents":[["Prim"],"Type"]}]}]]},"sourceSpan":{"start":[55,1],"name":"/private/tmp/pursuit-staging/.psc-package/psc-0.11.3/proxy/v2.0.0/src/Type/Proxy.purs","end":[55,41]}},{"children":[{"comments":null,"title":"Proxy3","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null}],"comments":"Value proxy for kind `Type -> Type -> Type` types.\n","title":"Proxy3","info":{"declType":"data","dataDeclType":"data","typeArguments":[["a",{"tag":"FunKind","contents":[{"tag":"NamedKind","contents":[["Prim"],"Type"]},{"tag":"FunKind","contents":[{"tag":"NamedKind","contents":[["Prim"],"Type"]},{"tag":"NamedKind","contents":[["Prim"],"Type"]}]}]}]]},"sourceSpan":{"start":[58,1],"name":"/private/tmp/pursuit-staging/.psc-package/psc-0.11.3/proxy/v2.0.0/src/Type/Proxy.purs","end":[58,43]}}]}],"resolvedDependencies":{},"version":"2.0.0","github":["purescript","purescript-proxy"],"versionTag":"v2.0.0","moduleMap":{},"compilerVersion":"0.11.3"}