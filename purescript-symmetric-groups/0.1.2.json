{"uploader":"hdgarrood","packageMeta":{"repository":{"url":"https://github.com/hdgarrood/purescript-symmetric-groups.git","type":"git"},"ignore":["**/.*","node_modules","bower_components","output"],"devDependencies":{"purescript-psci-support":"^3.0.0"},"dependencies":{"purescript-group":"^3.1.0","purescript-console":"^3.0.0","purescript-prelude":"^3.1.0","purescript-assert":"^3.0.0","purescript-integers":"^3.2.0","purescript-strings":"^3.3.1","purescript-sets":"^3.1.0","purescript-lists":"^4.10.0"},"name":"purescript-symmetric-groups","license":["MIT"]},"tagTime":"2017-11-30T15:51:15+0000","modules":[{"reExports":[{"moduleName":{"package":"purescript-integers","item":["Data","Int"]},"declarations":[{"children":[{"comments":null,"title":"Even","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"Odd","info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"eqParity","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Eq"],"Eq"]},{"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[107,8],"name":"/home/harry/code/purescript-symmetric-groups/bower_components/purescript-integers/src/Data/Int.purs","end":[107,38]}},{"comments":null,"title":"ordParity","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Ord"],"Ord"]},{"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[108,8],"name":"/home/harry/code/purescript-symmetric-groups/bower_components/purescript-integers/src/Data/Int.purs","end":[108,40]}},{"comments":null,"title":"showParity","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Show"],"Show"]},{"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[110,1],"name":"/home/harry/code/purescript-symmetric-groups/bower_components/purescript-integers/src/Data/Int.purs","end":[110,35]}},{"comments":null,"title":"boundedParity","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Bounded"],"Bounded"]},{"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[114,1],"name":"/home/harry/code/purescript-symmetric-groups/bower_components/purescript-integers/src/Data/Int.purs","end":[114,41]}},{"comments":null,"title":"semiringParity","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Semiring"],"Semiring"]},{"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[118,1],"name":"/home/harry/code/purescript-symmetric-groups/bower_components/purescript-integers/src/Data/Int.purs","end":[118,43]}},{"comments":null,"title":"ringParity","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Ring"],"Ring"]},{"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[125,1],"name":"/home/harry/code/purescript-symmetric-groups/bower_components/purescript-integers/src/Data/Int.purs","end":[125,35]}},{"comments":null,"title":"commutativeRingParity","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","CommutativeRing"],"CommutativeRing"]},{"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[128,1],"name":"/home/harry/code/purescript-symmetric-groups/bower_components/purescript-integers/src/Data/Int.purs","end":[128,57]}},{"comments":null,"title":"euclideanRingParity","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","EuclideanRing"],"EuclideanRing"]},{"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[130,1],"name":"/home/harry/code/purescript-symmetric-groups/bower_components/purescript-integers/src/Data/Int.purs","end":[130,53]}},{"comments":null,"title":"divisionRingParity","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","DivisionRing"],"DivisionRing"]},{"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[136,1],"name":"/home/harry/code/purescript-symmetric-groups/bower_components/purescript-integers/src/Data/Int.purs","end":[136,51]}},{"comments":null,"title":"fieldParity","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Field"],"Field"]},{"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[139,1],"name":"/home/harry/code/purescript-symmetric-groups/bower_components/purescript-integers/src/Data/Int.purs","end":[139,37]}}],"comments":"A type for describing whether an integer is even or odd.\n\nThe `Ord` instance considers `Even` to be less than `Odd`.\n\nThe `Semiring` instance allows you to ask about the parity of the results\nof arithmetical operations, given only the parities of the inputs. For\nexample, the sum of an odd number and an even number is odd, so\n`Odd + Even == Odd`. This also works for multiplication, eg. the product\nof two odd numbers is odd, and therefore `Odd * Odd == Odd`.\n\nMore generally, we have that\n\n```purescript\nparity x + parity y == parity (x + y)\nparity x * parity y == parity (x * y)\n```\n\nfor any integers `x`, `y`. (A mathematician would say that `parity` is a\n*ring homomorphism*.)\n\nAfter defining addition and multiplication on `Parity` in this way, the\n`Semiring` laws now force us to choose `zero = Even` and `one = Odd`.\nThis `Semiring` instance actually turns out to be a `Field`.\n","title":"Parity","info":{"declType":"data","dataDeclType":"data","typeArguments":[]},"sourceSpan":{"start":[105,1],"name":"/home/harry/code/purescript-symmetric-groups/bower_components/purescript-integers/src/Data/Int.purs","end":[105,25]}}]}],"name":"Data.SymmetricGroup","comments":"One important example of a group which arises very often in group theory\nand its applications is the *symmetric group* on some set X, which is\nthe group of bijective functions from X to itself. The group operation\nhere is function composition and the identity element is the identity\nfunction. (If I've lost you by this point, the first few of chapters of\nthe [PureScript numeric hierarchy\nguide](https://a-guide-to-the-purescript-numeric-hierarchy.readthedocs.io/en/latest/)\nshould help.)\n\nWe often restrict our attention to just the symmetric groups on finite\nsets, since they are a little easier to deal with. Since we are dealing\nwith a finite set, we might as well label the elements of the set from 1\nup to n (where n is the size of the set); the group structure will be\nthe same no matter how we have labelled the elements of the underlying\nset. The symmetric group on a set X can be written S(X); if X is the set\n{1,2,...,n} we often abuse notation and write the group S(X) as just\nS(n).\n\nSome vocabulary first: if f is a function from the set X to itself, we\nsay that x is a *fixed point* of f if and only if f(x) = x. We sometimes\nsay that \"f *fixes* x\" instead, since this is less of a mouthful than \"x\nis a fixed point of f\".\n\nWhen attempting to represent the group S(n) in PureScript, one approach\nmight be to define a type constructor of kind `Type -> Type`, where the\nargument is a type-level natural number representing n. This approach\nquickly runs into a problem, though, which is that there is no\n(ergonomic) type for natural numbers less than or equal to a certain\nnumber. For example, Idris has `Fin n`, which is the type of integers\nbetween 0 and n-1. Of course, it is possible to define a similar type in\nPureScript, but without dependent types it will not be nearly as\ncomfortable to use as Idris' `Fin`. However, we want to have some way of\nconverting elements of this set to standard PureScript functions\\*, but\nwithout an ergonomic type `Fin` we will need to use `Partial`\nconstraints (yuck).\n\nWe also would like to be able to do things like embed S(n) into S(n+1)\nwithout too much effort (that is, without having to convert between two\ndifferent types): note that every permutation f on a set of n elements\ncan be extended to a permutation f' on a set of n+1 elements just by\nsaying that f' fixes n+1 and does the same as f for everything else,\ni.e. f'(k) = f(k) for all k ≤ n.\n\nThere is a simple trick we can use to address this. We say that a\npermutation is *finitary* if and only if it fixes all but finitely many\npoints. For example, the permutation on the set of natural numbers which\nswaps 1 and 2 and fixes everything else is finitary; the permutation\nwhich swaps every even number with the odd number preceding it is not.\nIt turns out that the product of two finitary permutations is itself\nfinitary, and also that the inverse of a finitary permutation is\nfinitary (exercise!). Therefore the set of finitary permutations on a\nset X is a group (in fact a subgroup of S(X)), which we will refer to as\nFS(X).\n\nThe design adopted by this library is to define a type representing the\ngroup FS(ℕ) of finitary permutations on the natural numbers. Then, for\nany natural number n, there is a natural embedding of S(n) into FS(ℕ)\nby just fixing everything greater than n; in the same way there is a\nnatural embedding of S(k) into S(n) (within FS(ℕ)) whenever k < n.\n\nPerhaps surprisingly, [Cayley's\nTheorem](https://en.wikipedia.org/wiki/Cayley's_theorem) tells us that\nany finite group is isomorphic to a subgroup of S(n), so we can in fact\nrepresent any finite group at all using this library (although this\nfact might mostly just be a curiosity).\n\n---\n\n\\*note: we don't use standard PureScript functions directly, as it is\nnot an efficient representation for many of the operations we would like\nto be able to do, and also it is harder to guarantee that the function\nin question is bijective.\n","declarations":[{"children":[{"comments":null,"title":"eqSym","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Eq"],"Eq"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]}},"sourceSpan":{"start":[169,16],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[169,40]}},{"comments":null,"title":"ordSym","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Ord"],"Ord"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]}},"sourceSpan":{"start":[170,16],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[170,42]}},{"comments":null,"title":"showSym","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Show"],"Show"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]}},"sourceSpan":{"start":[172,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[172,29]}},{"comments":null,"title":"semigroupSym","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Semigroup"],"Semigroup"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]}},"sourceSpan":{"start":[183,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[183,39]}},{"comments":null,"title":"monoidSym","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Monoid"],"Monoid"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]}},"sourceSpan":{"start":[186,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[186,33]}},{"comments":null,"title":"groupSym","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Group"],"Group"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]}},"sourceSpan":{"start":[189,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[189,31]}}],"comments":"The type `Sym` represents the group FS(ℕ) of finitary permutations of the\nset of natural numbers. Values of this type cannot be constructed from\nfunctions of type `Int -> Int`, because we cannot easily verify that these\nare bijective. Instead, use `fromCycle` or `fromCycles`.\n\nIf f is a permutation, and k is the largest number which is not a fixed\npoint of f, then the amount of memory required to represent f at runtime\nis O(k). If k is very large, this may be a problem.\n\nThere does not appear to be consistent standard for which way composition\ngoes; some authors write `f <> g` to indicate the permutation given by\nfirst applying `g` and then `f`, and others use the same notation to\nindicate the permutation given by first applying `f` and then applying\n`g`. This is very unfortunate! The decision taken by this library is that\nthe group operation of `Sym` corresponds to normal function composition,\n`<<<` (see also: the docs for `asFunction`).\n\nThe time complexity of the group operation `f <> g` is O(max(n,m)), where\nn is the largest non-fixed point of f, and m is the largest non-fixed\npoint of g. The time complexity of `ginverse f` is O(n).\n","title":"Sym","info":{"declType":"data","dataDeclType":"newtype","typeArguments":[]},"sourceSpan":{"start":[140,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[140,30]}},{"children":[],"comments":"Generate a permutation from a single cycle. If the given cycle includes\nnonpositive or duplicate elements, they will be ignored.\n\n```purescript\nfromCycle (1:2:Nil) == fromCycle (1:2:1:Nil)\nfromCycle (1:2:Nil) == fromCycle (1:2:0:Nil)\nfromCycle (1:2:Nil) == fromCycle (1:2:(-1):Nil)\n```\n\n*Time complexity: O(n), where n is the length of the input list/cycle.*\n","title":"fromCycle","info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]}},"sourceSpan":{"start":[296,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[296,29]}},{"children":[],"comments":"Construct a permutation from a list of cycles.\n\n```purescript\nf = asFunction (fromCycles ((1 : 3 : Nil) : (2 : 4 : Nil) : Nil))\n\nf 1 == 3\nf 2 == 4\nf 3 == 1\nf 4 == 2\n```\n*Time complexity: O(nm), where n is the length of the longest cycle in the\nprovided list, and m is the length of the list.*\n","title":"fromCycles","info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}}]}]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]}},"sourceSpan":{"start":[283,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[283,37]}},{"children":[],"comments":"Represent a permutation as a list of cycles. Note that\n`asCycles <<< fromCycles` is not equal to `id`, because in general there\nare lots of different ways to write any given permutation as a product of\ncycles. However, `fromCycles <<< asCycles` is equal to `id`.\n\n```purescript\nasCycles (fromCycles ((1 : 2 : 3 : Nil) : Nil))\n == (1 : 2 : 3 : Nil) : Nil\n\nasCycles (fromCycles ((3 : 1 : 2 : Nil) : Nil))\n == (1 : 2 : 3 : Nil) : Nil\n```\n\n*Time complexity: Ω((n log n)(m log m)), where n is the length of the\nlongest cycle in the result and m is the number of cycles in the result\n(note that Ω denotes a lower bound whereas O denotes an upper bound).\nThe actual time complexity is probably worse than this but I gave up\ntrying to calculate it.*\n","title":"asCycles","info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}}]}]}},"sourceSpan":{"start":[210,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[210,35]}},{"children":[],"comments":"Convert a finitary permutation into a regular function. The resulting\nfunction fixes all negative numbers.\n\n```purescript\nf = asFunction (fromCycle (1 : 2 : 3 : Nil))\n\nf 1 == 2\nf 2 == 3\nf 3 == 1\nf 4 == 4\nf (-1) == (-1)\n```\n\nThis function agrees with the group operation of `Sym` in the following\nsense: for all `f, g :: Sym`, we have that:\n\n```purescript\nasFunction f <<< asFunction g == asFunction (f <> g)\n```\n\n*Time complexity: O(1).*\n","title":"asFunction","info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}]}},"sourceSpan":{"start":[268,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[268,32]}},{"children":[],"comments":"Compute the cycle containing a given point.\n\n```purescript\nf = fromCycles ((1 : 3 : Nil) : (2 : 4 : Nil) : Nil)\n\ncycleOf f 1 == 1 : 3 : Nil\ncycleOf f 2 == 2 : 4 : Nil\ncycleOf f 5 == Nil\n```\n\n*Time complexity: O(n), where n is the length of the resulting cycle.*\n","title":"cycleOf","info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","List","Types"],"List"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}]}]}},"sourceSpan":{"start":[234,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[234,34]}},{"children":[],"comments":"The smallest natural number N for which the given permutation fixes\nall numbers greater than or equal to N.\n\n```purescript\nminN (fromCycle (1:2:Nil)) == 3\n```\n\n*Time complexity: O(1).*\n","title":"minN","info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[325,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[325,19]}},{"children":[],"comments":"The inversions of a permutation, i.e. for a permutation f, this function\nreturns all pairs x, y such that `x < y` and `f x > f y`.\n\nThe parity of the number of inversions of a permutation is equal to the\nparity of the permutation itself.\n\n*Time complexity: O(n^2), where `n = minN f`.*\n","title":"inversions","info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}}]}]}},"sourceSpan":{"start":[400,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[400,43]}},{"children":[],"comments":"The parity of a permutation. All permutations can be expressed as products\nof 2-cycles: for example (1 2 3) can be written as (2 3)(1 3). The parity\nof a permutation is defined as the parity of the number of 2-cycles when\nit is written as a product of 2-cycles, so e.g. (1 2 3) is even.\n\nThis function is a group homomorphism from the group Sym to the additive\ngroup of the field of two elements (here represented by the `Parity`\ntype); that is,\n\n```purescript\nparity f + parity g = parity (f <> g)\n```\n\nholds for all permutations `f`, `g`.\n\nThe parity of a permutation is sometimes also called the \"sign\" or\n\"signature\".\n\n*Time complexity: O(nm), where, if the permutation is expressed as a\nproduct of disjoint cycles, n is the length of the longest cycle, and m\nis the number of cycles.*\n","title":"parity","info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]},{"tag":"TypeConstructor","contents":[["Data","Int"],"Parity"]}]}},"sourceSpan":{"start":[429,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[429,24]}},{"children":[],"comments":"The order of a permutation; the smallest positive integer n such that s^n\nis the identity. Restricting `Sym` to finitary permutations ensures that\nthis is always finite.\n\n```purescript\norder mempty == 1\norder (fromCycle (1:2:Nil)) == 2\norder (fromCycle (1:2:3:Nil)) == 3\n```\n\n*Time complexity: O(nm), where, if the permutation is expressed as a\nproduct of disjoint cycles, n is the length of the longest cycle, and m\nis the number of cycles.*\n","title":"order","info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}},"sourceSpan":{"start":[390,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[390,20]}},{"children":[],"comments":"`permutations n` gives you all permutations of the array with elements\nfrom 1 up to n. If `n` is not positive, the resulting array is empty.\n\n```purescript\npermutations 0 == []\npermutations 1 == [[1]]\npermutations 2 == [[2,1], [1,2]]\n```\n\n*Time complexity: O(n!).*\n","title":"permutations","info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]}}]}]}},"sourceSpan":{"start":[338,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[338,41]}},{"children":[],"comments":"`symmetric n` gives you every element of the group S(n) in an array.\n\n*Time complexity: O(n!).*\n","title":"symmetric","info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]}]}},"sourceSpan":{"start":[349,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[349,30]}},{"children":[],"comments":"`alternating n` gives you every element of the group A(n) -- that is, the\nsubgroup of S(n) given by the even permutations -- in an array.\n\n*Time complexity: O(n!).*\n","title":"alternating","info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Prim"],"Int"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Array"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]}]}},"sourceSpan":{"start":[356,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[356,32]}},{"children":[],"comments":"The set containing just the identity element of a group (i.e. `mempty`).\n\n*Time complexity: O(1).*\n","title":"trivialSubgroup","info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"tag":"TypeVar","contents":"a"}],"constraintData":null},{"tag":"ConstrainedType","contents":[{"constraintClass":[["Data","Group"],"Group"],"constraintArgs":[{"tag":"TypeVar","contents":"a"}],"constraintData":null},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Set"],"Set"]},{"tag":"TypeVar","contents":"a"}]}]}]},null]}},"sourceSpan":{"start":[439,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[439,55]}},{"children":[],"comments":"Given a set of permutations, form the subgroup generated by that set. This\nfunction is idempotent, that is, `subgroup (subgroup a) = subgroup a`.\n","title":"subgroup","info":{"declType":"value","type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Set"],"Set"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Set"],"Set"]},{"tag":"TypeConstructor","contents":[["Data","SymmetricGroup"],"Sym"]}]}]}},"sourceSpan":{"start":[456,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[456,31]}},{"children":[],"comments":"If `h` is a subgroup, then `actLeft s h` gives the coset formed by\napplying `s` to each element of `h` on the left.\n","title":"actLeft","info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"tag":"TypeVar","contents":"a"}],"constraintData":null},{"tag":"ConstrainedType","contents":[{"constraintClass":[["Data","Group"],"Group"],"constraintArgs":[{"tag":"TypeVar","contents":"a"}],"constraintData":null},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Set"],"Set"]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Set"],"Set"]},{"tag":"TypeVar","contents":"a"}]}]}]}]}]},null]}},"sourceSpan":{"start":[461,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[461,61]}},{"children":[],"comments":"If `h` is a subgroup of `g`, then `cosets h g` gives the set of cosets of\n`h` in `g`. Otherwise, the behaviour of this function is undefined.\n","title":"cosets","info":{"declType":"value","type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"tag":"TypeVar","contents":"a"}],"constraintData":null},{"tag":"ConstrainedType","contents":[{"constraintClass":[["Data","Group"],"Group"],"constraintArgs":[{"tag":"TypeVar","contents":"a"}],"constraintData":null},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Set"],"Set"]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Set"],"Set"]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Set"],"Set"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Set"],"Set"]},{"tag":"TypeVar","contents":"a"}]}}]}]}]}]}]},null]}},"sourceSpan":{"start":[466,1],"name":"/home/harry/code/purescript-symmetric-groups/src/Data/SymmetricGroup.purs","end":[466,70]}}]}],"resolvedDependencies":{"purescript-newtype":"2.0.0","purescript-group":"3.1.0","purescript-maps":"3.5.2","purescript-control":"3.3.1","purescript-console":"3.0.0","purescript-either":"3.1.0","purescript-arrays":"4.2.1","purescript-maybe":"3.0.0","purescript-type-equality":"2.1.0","purescript-distributive":"3.0.0","purescript-unfoldable":"3.0.0","purescript-invariant":"3.0.0","purescript-lazy":"3.0.0","purescript-monoid":"3.3.0","purescript-foldable-traversable":"3.6.1","purescript-tailrec":"3.3.0","purescript-gen":"1.1.1","purescript-prelude":"3.1.1","purescript-st":"3.0.0","purescript-bifunctors":"3.0.0","purescript-nonempty":"4.1.1","purescript-assert":"3.0.0","purescript-unsafe-coerce":"3.0.0","purescript-integers":"3.2.0","purescript-eff":"3.1.0","purescript-globals":"3.0.0","purescript-math":"2.1.0","purescript-psci-support":"3.0.0","purescript-tuples":"4.1.0","purescript-partial":"1.2.1","purescript-strings":"3.3.2","purescript-identity":"3.1.0","purescript-sets":"3.1.0","purescript-lists":"4.11.0","purescript-functions":"3.0.0"},"version":"0.1.2","github":["hdgarrood","purescript-symmetric-groups"],"versionTag":"v0.1.2","moduleMap":{"Data.BooleanAlgebra":"purescript-prelude","Data.Ring":"purescript-prelude","Data.NonEmpty":"purescript-nonempty","Data.Char.Gen":"purescript-strings","Data.Traversable.Accum.Internal":"purescript-foldable-traversable","Data.StrMap":"purescript-maps","Data.Semigroup.Commutative":"purescript-group","Control.Monad.Eff.Unsafe":"purescript-eff","Data.Int.Bits":"purescript-integers","Data.Bifunctor.Flip":"purescript-bifunctors","Data.String.CodePoints":"purescript-strings","Data.Ord":"purescript-prelude","Control.Monad.Gen":"purescript-gen","Data.Monoid.Dual":"purescript-monoid","Control.Monad.Rec.Class":"purescript-tailrec","Data.StrMap.ST.Unsafe":"purescript-maps","Data.Bitraversable":"purescript-foldable-traversable","Data.Boolean":"purescript-prelude","Data.Map":"purescript-maps","Control.Biapplicative":"purescript-bifunctors","Data.Array.ST.Iterator":"purescript-arrays","Data.Bounded":"purescript-prelude","Data.TraversableWithIndex":"purescript-foldable-traversable","Data.Int":"purescript-integers","Data.StrMap.Gen":"purescript-maps","Data.Show":"purescript-prelude","Data.Bifunctor.Clown":"purescript-bifunctors","Data.Foldable":"purescript-foldable-traversable","Control.Apply":"purescript-prelude","Data.Tuple.Nested":"purescript-tuples","Control.Monad":"purescript-prelude","Data.Lazy":"purescript-lazy","Data.Monoid":"purescript-monoid","Control.Monad.Eff.Uncurried":"purescript-eff","Data.Maybe.First":"purescript-maybe","Control.Bind":"purescript-prelude","Data.Monoid.Additive":"purescript-monoid","Data.Map.Gen":"purescript-maps","Data.String.Regex":"purescript-strings","Data.HeytingAlgebra":"purescript-prelude","Control.Alt":"purescript-control","Data.List.ZipList":"purescript-lists","Data.Ord.Unsafe":"purescript-prelude","Data.Semigroup":"purescript-prelude","Control.Monad.Eff":"purescript-eff","Data.Array.ST.Partial":"purescript-arrays","Data.StrMap.Unsafe":"purescript-maps","Data.Tuple":"purescript-tuples","Data.Semigroup.Foldable":"purescript-foldable-traversable","Control.Biapply":"purescript-bifunctors","Data.Distributive":"purescript-distributive","Type.Equality":"purescript-type-equality","Control.Alternative":"purescript-control","Data.Semiring":"purescript-prelude","Data.StrMap.ST":"purescript-maps","Data.Traversable.Accum":"purescript-foldable-traversable","Data.CommutativeRing":"purescript-prelude","Data.NaturalTransformation":"purescript-prelude","Data.Monoid.Conj":"purescript-monoid","Data.Unfoldable":"purescript-unfoldable","Control.Monad.ST":"purescript-st","Data.List.Types":"purescript-lists","Data.Group.Action":"purescript-group","Data.Functor":"purescript-prelude","Unsafe.Coerce":"purescript-unsafe-coerce","Data.List.Lazy.Types":"purescript-lists","Control.Category":"purescript-prelude","Control.Monad.Gen.Common":"purescript-gen","Data.Maybe":"purescript-maybe","Data.String.Regex.Unsafe":"purescript-strings","Data.Set":"purescript-sets","Control.Comonad":"purescript-control","Data.Function":"purescript-prelude","Data.List":"purescript-lists","Data.Field":"purescript-prelude","Data.List.Lazy":"purescript-lists","Data.EuclideanRing":"purescript-prelude","Data.Functor.Invariant":"purescript-invariant","Global.Unsafe":"purescript-globals","Data.String.Unsafe":"purescript-strings","Prelude":"purescript-prelude","Partial.Unsafe":"purescript-partial","Data.Array":"purescript-arrays","Data.Bifunctor.Product":"purescript-bifunctors","Control.Extend":"purescript-control","Control.Lazy":"purescript-control","Data.Function.Uncurried":"purescript-functions","Data.Eq":"purescript-prelude","Data.Either.Nested":"purescript-either","Data.Newtype":"purescript-newtype","Control.Monad.Eff.Console":"purescript-console","Data.Semigroup.Traversable":"purescript-foldable-traversable","Data.Bifunctor":"purescript-bifunctors","Test.Assert":"purescript-assert","Data.Monoid.Disj":"purescript-monoid","Control.Monad.Gen.Class":"purescript-gen","Data.Array.Partial":"purescript-arrays","Data.String.CaseInsensitive":"purescript-strings","Control.MonadPlus":"purescript-control","Data.Void":"purescript-prelude","Control.MonadZero":"purescript-control","Data.Bifunctor.Joker":"purescript-bifunctors","Data.FunctorWithIndex":"purescript-foldable-traversable","Data.DivisionRing":"purescript-prelude","Data.Bifunctor.Wrap":"purescript-bifunctors","PSCI.Support":"purescript-psci-support","Data.Maybe.Last":"purescript-maybe","Data.Unit":"purescript-prelude","Data.List.NonEmpty":"purescript-lists","Data.List.Lazy.NonEmpty":"purescript-lists","Data.Ordering":"purescript-prelude","Data.Identity":"purescript-identity","Math":"purescript-math","Data.String":"purescript-strings","Control.Plus":"purescript-control","Control.Monad.Eff.Class":"purescript-eff","Type.Row.Effect.Equality":"purescript-type-equality","Partial":"purescript-partial","Global":"purescript-globals","Data.Monoid.Multiplicative":"purescript-monoid","Data.Array.ST":"purescript-arrays","Control.Semigroupoid":"purescript-prelude","Data.Monoid.Alternate":"purescript-monoid","Data.Char":"purescript-strings","Data.Bifunctor.Join":"purescript-bifunctors","Data.Bifoldable":"purescript-foldable-traversable","Data.Monoid.Endo":"purescript-monoid","Data.List.Partial":"purescript-lists","Data.String.Regex.Flags":"purescript-strings","Data.Either":"purescript-either","Control.Applicative":"purescript-prelude","Data.FoldableWithIndex":"purescript-foldable-traversable","Data.Group":"purescript-group","Data.Traversable":"purescript-foldable-traversable","Data.String.Gen":"purescript-strings"},"compilerVersion":"0.11.4"}