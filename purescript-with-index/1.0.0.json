{"uploader":"paf31","packageMeta":{"repository":{"url":"git://github.com/paf31/purescript-with-index.git","type":"git"},"ignore":["**/.*","node_modules","bower_components","output"],"dependencies":{"purescript-newtype":"^2.0.0","purescript-monoid":"^3.3.0"},"name":"purescript-with-index","license":["BSD-3-Clause"]},"tagTime":"2017-10-14T02:00:39+0000","modules":[{"reExports":[],"name":"Data.WithIndex","comments":"A tiny library for composing indexed maps, folds and traversals.\n\nOne of the benefits of lenses and traversals is that they can be\ncreated, composed and used, using only the machinery available in base.\nFor more advanced use cases, there is the `purescript-lens` library.\n\nThis library tries to provide something similar for indexed traversals.\n\nMany data structures provide functions which map or traverse while providing\naccess to an index. See for example the `TraversableWithIndex` type class.\nUsing this module, it is possible to compose such maps and traversals, \nwhile combining indices using some `Monoid`.\n\nTo use this library, wrap any maps or traversals you wish to use with the `WithIndex`\nconstructor. You may also need to change the index type using the `reindex`\nfunction. These wrapped functions can be composed using the composition operator.\n\nRegular maps and traversals can also be used, via the `withoutIndex` function.\n","declarations":[{"children":[{"comments":null,"title":"Indexed","info":{"arguments":[{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"i"}]},{"tag":"TypeVar","contents":"a"}]}}]},{"tag":"TypeVar","contents":"b"}]}}],"declType":"dataConstructor"},"sourceSpan":null},{"comments":null,"title":"newtypeIndexed","info":{"declType":"instance","dependencies":[],"type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Newtype"],"Newtype"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","WithIndex"],"Indexed"]},{"tag":"TypeVar","contents":"i"}]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]},{"tag":"TypeWildcard","contents":{"start":[52,59],"name":"/Users/phil/Documents/Code/purescript/purescript-with-index/src/Data/WithIndex.purs","end":[52,60]}}]}},"sourceSpan":{"start":[52,8],"name":"/Users/phil/Documents/Code/purescript/purescript-with-index/src/Data/WithIndex.purs","end":[52,60]}},{"comments":null,"title":"semigroupoidIndexed","info":{"declType":"instance","dependencies":[{"constraintClass":[["Data","Semigroup"],"Semigroup"],"constraintArgs":[{"tag":"TypeVar","contents":"i"}],"constraintData":null}],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Semigroupoid"],"Semigroupoid"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","WithIndex"],"Indexed"]},{"tag":"TypeVar","contents":"i"}]}}]}},"sourceSpan":{"start":[54,1],"name":"/Users/phil/Documents/Code/purescript/purescript-with-index/src/Data/WithIndex.purs","end":[54,72]}},{"comments":null,"title":"categoryIndexed","info":{"declType":"instance","dependencies":[{"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"tag":"TypeVar","contents":"i"}],"constraintData":null}],"type":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Category"],"Category"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","WithIndex"],"Indexed"]},{"tag":"TypeVar","contents":"i"}]}}]}},"sourceSpan":{"start":[57,1],"name":"/Users/phil/Documents/Code/purescript/purescript-with-index/src/Data/WithIndex.purs","end":[57,61]}}],"comments":"A wrapper for a mapping or traversal function which uses an index.\n\nFor example, using the `Data.Map` module:\n\n```purescript\nWithIndex mapWithKey\n  :: WithIndex i (a -> b) (Map i a -> Map i b)\n```\n\nThese wrapped functions can be composed using the composition operator:\n\n```purescript\nWithIndex mapWithKey . WithIndex mapWithKey\n  :: Monoid i =>\n     WithIndex i (a -> b) (Map i (Map i a) -> Map i (Map i b))\n```\n\nand then applied using `withIndex`:\n\n```purescript\nwithIndex $ WithIndex mapWithKey . WithIndex mapWithKey\n  :: Monoid i => (i -> a -> b) -> Map i (Map i a) -> Map i (Map i b)\n```\n","title":"Indexed","info":{"declType":"data","dataDeclType":"newtype","typeArguments":[["i",null],["a",null],["b",null]]},"sourceSpan":{"start":[50,1],"name":"/Users/phil/Documents/Code/purescript/purescript-with-index/src/Data/WithIndex.purs","end":[50,48]}},{"children":[],"comments":"Change the @Monoid@ used to combine indices.\n\nFor example, to keep track of only the first index seen, use `Data.Maybe.First`:\n\n```purescript\nreindex (First . pure)\n  :: WithIndex i a b -> WithIndex (First i) a b\n```\n\nor keep track of all indices using a list\n\n```purescript\nreindex singleton\n  :: WithIndex i a b -> WithIndex (List i) a b\n```\n","title":"reindex","info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["j",{"tag":"ForAll","contents":["i",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"i"}]},{"tag":"TypeVar","contents":"j"}]}}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","WithIndex"],"Indexed"]},{"tag":"TypeVar","contents":"i"}]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","WithIndex"],"Indexed"]},{"tag":"TypeVar","contents":"j"}]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]}]},null]},null]},null]},null]}},"sourceSpan":{"start":[75,1],"name":"/Users/phil/Documents/Code/purescript/purescript-with-index/src/Data/WithIndex.purs","end":[75,70]}},{"children":[],"comments":"Turn a regular function into an wrapped function, so that it can be\ncomposed with other wrapped functions.\n\nFor example, to traverse two layers, keeping only the first index:\n\n```purescript\nWithIndex mapWithKey . withoutIndex map\n  :: Monoid i =>\n     WithIndex i (a -> b) (Map i (Map k a) -> Map i (Map k b))\n```\n","title":"withoutIndex","info":{"declType":"value","type":{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["i",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Data","Monoid"],"Monoid"],"constraintArgs":[{"tag":"TypeVar","contents":"i"}],"constraintData":null},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","WithIndex"],"Indexed"]},{"tag":"TypeVar","contents":"i"}]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]}]},null]},null]},null]}},"sourceSpan":{"start":[88,1],"name":"/Users/phil/Documents/Code/purescript/purescript-with-index/src/Data/WithIndex.purs","end":[88,68]}}]}],"resolvedDependencies":{"purescript-newtype":"2.0.0","purescript-control":"3.3.1","purescript-invariant":"3.0.0","purescript-monoid":"3.3.0","purescript-prelude":"3.1.0"},"version":"1.0.0","github":["paf31","purescript-with-index"],"versionTag":"v1.0.0","moduleMap":{"Data.BooleanAlgebra":"purescript-prelude","Data.Ring":"purescript-prelude","Data.Ord":"purescript-prelude","Data.Monoid.Dual":"purescript-monoid","Data.Boolean":"purescript-prelude","Data.Bounded":"purescript-prelude","Data.Show":"purescript-prelude","Control.Apply":"purescript-prelude","Control.Monad":"purescript-prelude","Data.Monoid":"purescript-monoid","Control.Bind":"purescript-prelude","Data.Monoid.Additive":"purescript-monoid","Data.HeytingAlgebra":"purescript-prelude","Control.Alt":"purescript-control","Data.Ord.Unsafe":"purescript-prelude","Data.Semigroup":"purescript-prelude","Control.Alternative":"purescript-control","Data.Semiring":"purescript-prelude","Data.CommutativeRing":"purescript-prelude","Data.NaturalTransformation":"purescript-prelude","Data.Monoid.Conj":"purescript-monoid","Data.Functor":"purescript-prelude","Control.Category":"purescript-prelude","Control.Comonad":"purescript-control","Data.Function":"purescript-prelude","Data.Field":"purescript-prelude","Data.EuclideanRing":"purescript-prelude","Data.Functor.Invariant":"purescript-invariant","Prelude":"purescript-prelude","Control.Extend":"purescript-control","Control.Lazy":"purescript-control","Data.Eq":"purescript-prelude","Data.Newtype":"purescript-newtype","Data.Monoid.Disj":"purescript-monoid","Control.MonadPlus":"purescript-control","Data.Void":"purescript-prelude","Control.MonadZero":"purescript-control","Data.DivisionRing":"purescript-prelude","Data.Unit":"purescript-prelude","Data.Ordering":"purescript-prelude","Control.Plus":"purescript-control","Data.Monoid.Multiplicative":"purescript-monoid","Control.Semigroupoid":"purescript-prelude","Data.Monoid.Alternate":"purescript-monoid","Data.Monoid.Endo":"purescript-monoid","Control.Applicative":"purescript-prelude"},"compilerVersion":"0.11.4"}